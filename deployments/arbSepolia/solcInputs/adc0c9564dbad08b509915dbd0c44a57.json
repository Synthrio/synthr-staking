{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/metatx/ERC2771Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (metatx/ERC2771Context.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Context variant with ERC2771 support.\n *\n * WARNING: Avoid using this pattern in contracts that rely in a specific calldata length as they'll\n * be affected by any forwarder whose `msg.data` is suffixed with the `from` address according to the ERC2771\n * specification adding the address size in bytes (20) to the calldata size. An example of an unexpected\n * behavior could be an unintended fallback (or another function) invocation while trying to invoke the `receive`\n * function only accessible if `msg.data.length == 0`.\n *\n * WARNING: The usage of `delegatecall` in this contract is dangerous and may result in context corruption.\n * Any forwarded request to this contract triggering a `delegatecall` to itself will result in an invalid {_msgSender}\n * recovery.\n */\nabstract contract ERC2771Context is Context {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable _trustedForwarder;\n\n    /**\n     * @dev Initializes the contract with a trusted forwarder, which will be able to\n     * invoke functions on this contract on behalf of other accounts.\n     *\n     * NOTE: The trusted forwarder can be replaced by overriding {trustedForwarder}.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address trustedForwarder_) {\n        _trustedForwarder = trustedForwarder_;\n    }\n\n    /**\n     * @dev Returns the address of the trusted forwarder.\n     */\n    function trustedForwarder() public view virtual returns (address) {\n        return _trustedForwarder;\n    }\n\n    /**\n     * @dev Indicates whether any particular address is the trusted forwarder.\n     */\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return forwarder == trustedForwarder();\n    }\n\n    /**\n     * @dev Override for `msg.sender`. Defaults to the original `msg.sender` whenever\n     * a call is not performed by the trusted forwarder or the calldata length is less than\n     * 20 bytes (an address length).\n     */\n    function _msgSender() internal view virtual override returns (address) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (isTrustedForwarder(msg.sender) && calldataLength >= contextSuffixLength) {\n            return address(bytes20(msg.data[calldataLength - contextSuffixLength:]));\n        } else {\n            return super._msgSender();\n        }\n    }\n\n    /**\n     * @dev Override for `msg.data`. Defaults to the original `msg.data` whenever\n     * a call is not performed by the trusted forwarder or the calldata length is less than\n     * 20 bytes (an address length).\n     */\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (isTrustedForwarder(msg.sender) && calldataLength >= contextSuffixLength) {\n            return msg.data[:calldataLength - contextSuffixLength];\n        } else {\n            return super._msgData();\n        }\n    }\n\n    /**\n     * @dev ERC-2771 specifies the context as being a single address (20 bytes).\n     */\n    function _contextSuffixLength() internal view virtual override returns (uint256) {\n        return 20;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"./IERC721.sol\";\nimport {IERC721Receiver} from \"./IERC721Receiver.sol\";\nimport {IERC721Metadata} from \"./extensions/IERC721Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {Strings} from \"../../utils/Strings.sol\";\nimport {IERC165, ERC165} from \"../../utils/introspection/ERC165.sol\";\nimport {IERC721Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\nabstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors {\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    mapping(uint256 tokenId => address) private _owners;\n\n    mapping(address owner => uint256) private _balances;\n\n    mapping(uint256 tokenId => address) private _tokenApprovals;\n\n    mapping(address owner => mapping(address operator => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}\n     */\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n\n        return _getApproved(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     *\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\n     * core ERC721 logic MUST be matched with the use of {_increaseBalance} to keep balances\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\n     */\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\n     * particular (ignoring whether it is owned by `owner`).\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\n     * Reverts if `spender` does not have approval from the provided `owner` for the given token or for all its assets\n     * the `spender` for the specific `tokenId`.\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\n     *\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\n     * remain consistent with one another.\n     */\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        unchecked {\n            _balances[account] += value;\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner\n     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that\n     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n\n    /**\n     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients\n     * are aware of the ERC721 standard to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is like {safeTransferFrom} in the sense that it invokes\n     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `tokenId` token must exist and be owned by `from`.\n     * - `to` cannot be the zero address.\n     * - `from` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is\n     * either the owner of the token, or approved to operate on all tokens held by this owner.\n     *\n     * Emits an {Approval} event.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n\n    /**\n     * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not\n     * emitted in the context of transfers.\n     */\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Requirements:\n     * - operator can't be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).\n     * Returns the owner.\n     *\n     * Overrides to ownership logic should be done to {_ownerOf}.\n     */\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n\n    /**\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address. This will revert if the\n     * recipient doesn't accept the token transfer. The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC721} from \"../ERC721.sol\";\nimport {Context} from \"../../../utils/Context.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be burned (destroyed).\n */\nabstract contract ERC721Burnable is Context, ERC721 {\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        _update(address(0), tokenId, _msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/controller/GaugeController.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/// @notice depositer get reward tokens on the basis or reward per block\ncontract GaugeController is AccessControl {\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant CONTROLLER_ROLE = keccak256(\"CONTROLLER_ROLE\");\n    bytes32 public constant POOL_ROLE = keccak256(\"POOL_ROLE\");\n    uint256 public constant ACC_REWARD_PRECISION = 1e18;\n    uint256 public constant MAX_REWARD_TOKEN = 8;\n\n    /// @notice Info of each gauge controller user.\n    /// `amount` LP token amount the user has provided.\n    /// `rewardDebt` The amount of reward token entitled to the user.\n    struct UserInfo {\n        uint256 amount;\n        int256[8] rewardDebt;\n    }\n\n    /// @notice Info of each gauge pool.\n    struct PoolInfo {\n        uint256 index;\n        uint256 epoch;\n        uint64 lastRewardBlock;\n    }\n\n    /// @notice Info of each token in pool.\n    struct RewardInfo {\n        address token;\n        uint256 rewardPerBlock;\n        uint256 accRewardPerShare;\n    }\n\n    /// @notice Info of each pool.\n    mapping(address => PoolInfo) public poolInfo;\n    /// @notice Address of the LP token for each pool.\n    mapping(address => IERC20) public lpToken;\n\n    mapping(address => RewardInfo[8]) public reward;\n\n    /// @notice Info of each user that stakes LP tokens.\n    mapping(address => mapping(address => UserInfo)) public userInfo;\n\n    event Claimed(address indexed user, address indexed pool, uint256 amount);\n    event LogPoolAddition(address indexed pool, address indexed lpToken);\n    event LogSetPool(address indexed pool, RewardInfo[] poolReward);\n    event LogUpdatePool(address indexed pool, uint64 lastRewardBlock);\n    event EpochUpdated(address indexed pool, uint256 newMaxRewardToken);\n    event SetMaxRewardToken(uint256 newMaxRewardToken);\n\n    constructor(address _admin) {\n        _grantRole(CONTROLLER_ROLE, _admin);\n    }\n\n    function userRewards(address _pool, address _user) external view returns (int256[MAX_REWARD_TOKEN] memory) {\n        return userInfo[_pool][_user].rewardDebt;\n    }\n\n    /// @notice View function to see pending reward of by token on frontend.\n    /// @param _pool The address of the pool. See `poolInfo`.\n    /// @param _user Address of user.\n    /// @return pending_ reward for a given user.\n    function userRewardByToken(address _pool, address _user, uint256 indexOfRewardToken)\n        external\n        view\n        returns (uint256 pending_)\n    {\n        PoolInfo memory _poolInfo = poolInfo[_pool];\n        UserInfo memory user = userInfo[_pool][_user];\n        RewardInfo[MAX_REWARD_TOKEN] memory _rewardInfo = reward[_pool];\n        uint256 lpSupply = lpToken[_pool].balanceOf(_pool);\n        if (block.number > _poolInfo.lastRewardBlock && lpSupply != 0) {\n            pending_ += _pendingRewardForToken(\n                user.amount,\n                user.rewardDebt[indexOfRewardToken],\n                lpSupply,\n                _rewardInfo[indexOfRewardToken].accRewardPerShare,\n                _rewardInfo[indexOfRewardToken].rewardPerBlock,\n                _poolInfo.lastRewardBlock,\n                block.number\n            );\n        }\n    }\n\n    /// @notice View function to see pending reward at current block on frontend.\n    /// @param _pool The address of the pool. See `poolInfo`.\n    /// @param _user Address of user.\n    /// @return pending_ reward for a given user.\n    function pendingReward(address _pool, address _user) external view returns (uint256 pending_) {\n        pending_ = _pendingRewardAmount(_pool, _user, block.number);\n    }\n\n    /// @notice View function to see pending reward at future block on frontend.\n    /// @param _pool The address of the pool. See `poolInfo`.\n    /// @param _user Address of user.\n    /// @return pending_ reward for a given user.\n    function pendingRewardAtBlock(address _pool, address _user, uint256 _blockNumber)\n        external\n        view\n        returns (uint256 pending_)\n    {\n        pending_ = _pendingRewardAmount(_pool, _user, _blockNumber);\n    }\n\n    /// @notice Add a new LP to the pool. Can only be called by the owner.\n    /// DO NOT add the same LP token more than once. Rewards will be messed up if you do.\n    /// @param _lpToken Address of the LP ERC-20 token.\n    function addPool(address _lpToken, address _pool, RewardInfo[] memory _reward) external {\n        require(hasRole(CONTROLLER_ROLE, msg.sender), \"GaugeController: not authorized\");\n        lpToken[_pool] = IERC20(_lpToken);\n\n        poolInfo[_pool] = PoolInfo({epoch: 0, lastRewardBlock: uint64(block.number), index: _reward.length - 1});\n\n        RewardInfo[MAX_REWARD_TOKEN] storage _rewardInfo = reward[_pool];\n        for (uint256 i = 0; i < _reward.length; ++i) {\n            _rewardInfo[i] = _reward[i];\n        }\n\n        _grantRole(POOL_ROLE, _pool);\n        emit LogPoolAddition(_pool, address(_lpToken));\n    }\n\n    /// @notice function to add reward token in pool on frontend.\n    /// @param _pool The address of the pool. See `poolInfo`.\n    /// @param _reward array of reward token info to add in pool\n    function addRewardToken(address _pool, RewardInfo[] memory _reward) external {\n        require(hasRole(CONTROLLER_ROLE, msg.sender), \"GaugeController: not authorized\");\n        PoolInfo memory _poolInfo = poolInfo[_pool];\n        uint256 _index = _poolInfo.index + 1;\n        require(_index + _reward.length <= MAX_REWARD_TOKEN, \"GaugeController: excced reward tokens\");\n        RewardInfo[MAX_REWARD_TOKEN] storage _rewardInfo = reward[_pool];\n        uint256 _len = _index + _reward.length;\n        for (uint256 i = _index; i < _len; ++i) {\n            _rewardInfo[i] = _reward[i - _index];\n        }\n        poolInfo[_pool].index += _reward.length;\n        emit LogSetPool(_pool, _reward);\n    }\n\n    /// @notice update epoch for given pool\n    /// @param _pool Pool address of pool to be updated. Make sure to update all active pools.\n    /// @param _indexes index of rewardInfo array.\n    /// @param _rewardPerBlock array of rewardPerBlock\n    function updateEpoch(\n        address _pool,\n        address _user,\n        uint256[] memory _indexes,\n        uint256[] memory _rewardPerBlock,\n        uint256[] memory _rewardAmount\n    ) external {\n        require(hasRole(CONTROLLER_ROLE, msg.sender), \"GaugeController: not authorized\");\n        require(_indexes.length == _rewardPerBlock.length, \"GaugeController: length of array doesn't mach\");\n\n        RewardInfo[MAX_REWARD_TOKEN] storage _rewardInfo = reward[_pool];\n\n        for (uint256 i = 0; i < _indexes.length; ++i) {\n            _rewardInfo[_indexes[i]].rewardPerBlock = _rewardPerBlock[i];\n            IERC20(_rewardInfo[_indexes[i]].token).safeTransferFrom(_user, address(this), _rewardAmount[i]);\n        }\n\n        poolInfo[_pool].epoch++;\n        emit EpochUpdated(_pool, poolInfo[_pool].epoch);\n    }\n\n    /// @notice Deposit LP tokens to pool for syUSD allocation.\n    /// @param _pool The address of the pool. See `poolInfo`.\n    /// @param _amount LP token amount to deposit.\n    /// @param _to The receiver of `amount` deposit benefit.\n    function updateReward(address _pool, address _to, uint256 _amount, bool _increase) external {\n        require(hasRole(POOL_ROLE, msg.sender), \"GaugeController: not authorized\");\n        PoolInfo memory _poolInfo = updatePool(_pool);\n        UserInfo memory _user = userInfo[_pool][_to];\n        RewardInfo[MAX_REWARD_TOKEN] memory rewardInfo = reward[_pool];\n\n        int256[MAX_REWARD_TOKEN] memory _rewardDebt = _user.rewardDebt;\n\n        // Effects\n        for (uint256 i = 0; i <= _poolInfo.index; ++i) {\n            int256 _calRewardDebt = _calAccReward(rewardInfo[i].accRewardPerShare, _amount);\n            if (_increase) {\n                _user.amount += _amount;\n                _rewardDebt[i] += _calRewardDebt;\n            } else {\n                _user.amount -= _amount;\n                _rewardDebt[i] -= _calRewardDebt;\n            }\n        }\n\n        _user.rewardDebt = _rewardDebt;\n        userInfo[_pool][_to] = _user;\n    }\n\n    /// @notice Claim proceeds for transaction sender to `to`.\n    /// @param _pool The address of the pool. See `poolInfo`.\n    /// @param _to Receiver of syUSD rewards.\n    function claim(address _pool, address _to) external {\n        PoolInfo memory _poolInfo = updatePool(_pool);\n        UserInfo memory _user = userInfo[_pool][msg.sender];\n        RewardInfo[MAX_REWARD_TOKEN] memory rewardInfo = reward[_pool];\n        uint256 _totalPendingReward;\n        for (uint256 i = 0; i <= _poolInfo.index; ++i) {\n            (int256 accumulatedReward, uint256 _pendingReward) = _claimForToken(\n                _user.amount, _user.rewardDebt[i], rewardInfo[i].accRewardPerShare, rewardInfo[i].token, _to\n            );\n            // Effects\n            _user.rewardDebt[i] = accumulatedReward;\n            _totalPendingReward += _pendingReward;\n        }\n        userInfo[_pool][msg.sender] = _user;\n        emit Claimed(msg.sender, _pool, _totalPendingReward);\n    }\n\n    /// @notice Claim proceeds for transaction sender to `to`.\n    /// @param _pool The address of the pool. See `poolInfo`.\n    /// @param _to Receiver of syUSD rewards.\n    /// @param _index token index in reward tokens of pool.\n    function claimForToken(address _pool, address _to, uint256 _index) external {\n        updatePool(_pool);\n        UserInfo memory _user = userInfo[_pool][msg.sender];\n        RewardInfo[MAX_REWARD_TOKEN] memory rewardInfo = reward[_pool];\n\n        (int256 accumulatedReward, uint256 _pendingReward) = _claimForToken(\n            _user.amount, _user.rewardDebt[_index], rewardInfo[_index].accRewardPerShare, rewardInfo[_index].token, _to\n        );\n\n        _user.rewardDebt[_index] = accumulatedReward;\n\n        userInfo[_pool][msg.sender] = _user;\n        emit Claimed(msg.sender, _pool, _pendingReward);\n    }\n\n    /// @notice Withdraw LP tokens from pool and claim proceeds for transaction sender to `to`.\n    /// @param _pool The address of the pool. See `poolInfo`.\n    /// @param _amount LP token amount to withdraw.\n    /// @param _to Receiver of the LP tokens and syUSD rewards.\n    function decreaseRewardAndClaim(address _pool, uint256 _amount, address _to) external {\n        require(hasRole(POOL_ROLE, msg.sender), \"GaugeController: not authorized\");\n        PoolInfo memory _poolInfo = updatePool(_pool);\n        UserInfo memory _user = userInfo[_pool][_to];\n        RewardInfo[MAX_REWARD_TOKEN] memory rewardInfo = reward[_pool];\n        uint256 _totalPendingReward;\n        for (uint256 i = 0; i <= _poolInfo.index; ++i) {\n            int256 accumulatedReward = _calAccReward(rewardInfo[i].accRewardPerShare, _user.amount);\n            uint256 _pendingReward = uint256(accumulatedReward - (_user.rewardDebt[i]));\n\n            // Effects\n            _user.rewardDebt[i] = accumulatedReward - (_calAccReward(_amount, rewardInfo[i].accRewardPerShare));\n            // Interactions\n            if (_pendingReward != 0) {\n                IERC20(rewardInfo[i].token).safeTransfer(_to, _pendingReward);\n                _totalPendingReward += _pendingReward;\n            }\n        }\n\n        _user.amount -= _amount;\n        userInfo[_pool][_to] = _user;\n\n        emit Claimed(_to, _pool, _totalPendingReward);\n    }\n\n    /// @notice Update reward variables of the given pool.\n    /// @param _pool The address of the pool. See `poolInfo`.\n    /// @return _poolInfo Returns the pool that was updated.\n    function updatePool(address _pool) public returns (PoolInfo memory _poolInfo) {\n        _poolInfo = poolInfo[_pool];\n        RewardInfo[MAX_REWARD_TOKEN] storage _rewardInfo = reward[_pool];\n\n        uint256 lpSupply = lpToken[_pool].balanceOf(_pool);\n        if (block.number > _poolInfo.lastRewardBlock && lpSupply > 0) {\n            uint256 _index = _poolInfo.index + 1;\n            for (uint256 i = 0; i < _index; ++i) {\n                _rewardInfo[i].accRewardPerShare += _calAccFromRewardPerBlock(\n                    _poolInfo.lastRewardBlock, _rewardInfo[i].rewardPerBlock, lpSupply, block.number\n                );\n            }\n        }\n        _poolInfo.lastRewardBlock = uint64(block.number);\n        poolInfo[_pool] = _poolInfo;\n        emit LogUpdatePool(_pool, uint64(block.number));\n    }\n\n    function _calAccReward(uint256 _accRewardPerShare, uint256 _amount) internal pure returns (int256) {\n        return int256((_amount * _accRewardPerShare) / ACC_REWARD_PRECISION);\n    }\n\n    function _calAccRewardPerShare(uint256 _rewardAmount, uint256 _lpSupply) internal pure returns (uint256) {\n        return (_rewardAmount * ACC_REWARD_PRECISION) / _lpSupply;\n    }\n\n    function _calRewardAmount(uint256 _lastRewardBlock, uint256 _rewardPerBlock, uint256 _blockNumber)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 blocks = _blockNumber - _lastRewardBlock;\n        return blocks * _rewardPerBlock;\n    }\n\n    function _calAccFromRewardPerBlock(\n        uint256 _lastRewardBlock,\n        uint256 _rewardPerBlock,\n        uint256 _lpSupply,\n        uint256 _blockNumber\n    ) internal pure returns (uint256) {\n        uint256 rewardAmount = _calRewardAmount(_lastRewardBlock, _rewardPerBlock, _blockNumber);\n        return _calAccRewardPerShare(rewardAmount, _lpSupply);\n    }\n\n    function _pendingRewardForToken(\n        uint256 _amount,\n        int256 _rewardDebt,\n        uint256 _lpSupply,\n        uint256 _accRewardPerShare,\n        uint256 _rewardPerBlock,\n        uint256 _lastRewardBlock,\n        uint256 _blockNumber\n    ) internal pure returns (uint256 _pending) {\n        _accRewardPerShare += _calAccFromRewardPerBlock(_lastRewardBlock, _rewardPerBlock, _lpSupply, _blockNumber);\n        _pending = uint256(_calAccReward(_accRewardPerShare, _amount) - (_rewardDebt));\n    }\n\n    function _pendingRewardAmount(address _pool, address _user, uint256 _blockNumber)\n        internal\n        view\n        returns (uint256 pending_)\n    {\n        PoolInfo memory _poolInfo = poolInfo[_pool];\n        UserInfo memory user = userInfo[_pool][_user];\n        RewardInfo[MAX_REWARD_TOKEN] memory _rewardInfo = reward[_pool];\n        uint256 lpSupply = lpToken[_pool].balanceOf(_pool);\n        if (block.number > _poolInfo.lastRewardBlock && lpSupply != 0) {\n            for (uint256 i = 0; i <= _poolInfo.index; ++i) {\n                pending_ += _pendingRewardForToken(\n                    user.amount,\n                    user.rewardDebt[i],\n                    lpSupply,\n                    _rewardInfo[i].accRewardPerShare,\n                    _rewardInfo[i].rewardPerBlock,\n                    _poolInfo.lastRewardBlock,\n                    _blockNumber\n                );\n            }\n        }\n    }\n\n    function _claimForToken(\n        uint256 _amount,\n        int256 _rewardDebt,\n        uint256 _accRewardPerShare,\n        address _token,\n        address _to\n    ) internal returns (int256 _accmulatedReward, uint256 _pendingReward) {\n        _accmulatedReward = _calAccReward(_accRewardPerShare, _amount);\n\n        _pendingReward = uint256(_accmulatedReward - _rewardDebt);\n\n        if (_pendingReward != 0) {\n            IERC20(_token).safeTransfer(_to, _pendingReward);\n        }\n    }\n}\n"
    },
    "contracts/farming/BaseDexLpFarming.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\n/// @notice The (older) DexLpFarming contract gives out a constant number of REWARD_TOKEN tokens per block.\ncontract BaseDexLpFarming is Ownable2Step {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant ACC_REWARD_PRECISION = 1e18;\n\n    uint256 public totalLiquidity;\n\n    /// @notice Address of reward token contract.\n    IERC20 public immutable REWARD_TOKEN;\n\n    /// @notice Info of each DexLpFarming user.\n    /// `amount` Liquidity amount the user has provided.\n    /// `rewardDebt` The amount of reward token entitled to the user.\n    struct UserInfo {\n        uint256 amount;\n        uint256 liquidityX;\n        int256 rewardDebt;\n    }\n\n    /// @notice Info of each DexLpFarming pool.\n    /// `lastRewardBlock` The last pool updated timestamp.\n    /// `rewardPerBlock` The total amount of reward to distribute.\n    /// Also known as the amount of reward token to distribute per block.\n    /// `accRewardPerShare` reward per liquidity amount\n    struct PoolInfo {\n        uint64 lastRewardBlock;\n        uint128 accRewardPerShare;\n        uint256 rewardPerBlock;\n        uint256 currentEpoch;\n    }\n\n    /// @notice Info of each DexLpFarming pool.\n    PoolInfo public pool;\n\n    /// @notice Info of each user that stakes LP tokens.\n    mapping(address => UserInfo) public userInfo;\n\n    /// @notice amount of token id of user has deposited in pool.\n    mapping(address => mapping(uint256 => uint256)) public userTokenAmount;\n\n    event Deposit(address indexed user, uint256[] tokenId);\n    event Withdraw(address indexed user, uint256[] tokenId);\n    event WithdrawAndHarvest(address indexed user, uint256[] tokenId, uint256 amount);\n    event Harvest(address indexed user, uint256 amount);\n\n    event LogUpdatePool(uint64 lastRewardBlock, uint256 lpSupply, uint256 accRewardPerShare);\n\n    event LogRewardPerBlock(uint256 rewardPerBlock, uint256 indexed currentEpoch, uint256 amount);\n\n    /// @param _rewardToken The REWARD token contract address.\n    constructor(IERC20 _rewardToken) Ownable(msg.sender) {\n        REWARD_TOKEN = _rewardToken;\n    }\n\n    /// @notice Returns if token id deposited by user.\n    /// @param _user depositer address\n    /// @param _tokenId deposited token id\n    function isTokenDeposited(address _user, uint256 _tokenId) external view returns (bool) {\n        if (userTokenAmount[_user][_tokenId] != 0) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @notice Sets the reward per second to be distributed. Can only be called by the owner.\n    /// @param _rewardPerBlock The amount of reward token to be distributed per block number.\n    /// @param _amount The amount of reward token to be deposit in dexLpFarmin.\n    /// @param _user address from which reward is to be distributed.\n    function setRewardPerBlock(uint256 _rewardPerBlock, uint256 _amount, address _user) external onlyOwner {\n        PoolInfo memory _pool = pool;\n        _pool.rewardPerBlock = _rewardPerBlock;\n        _pool.lastRewardBlock = uint64(block.number);\n        ++_pool.currentEpoch;\n        pool = _pool;\n\n        REWARD_TOKEN.safeTransferFrom(_user, address(this), _amount);\n\n        emit LogRewardPerBlock(_rewardPerBlock, _pool.currentEpoch, _amount);\n    }\n\n    function _pendingReward(address _user, uint256 _lpSupply) internal view returns (uint256 _pending) {\n        PoolInfo memory _pool = pool;\n        UserInfo memory user = userInfo[_user];\n        uint256 _accRewardPerShare = _pool.accRewardPerShare;\n        if (block.number > _pool.lastRewardBlock && _lpSupply != 0) {\n            uint256 _blocks = block.number - (_pool.lastRewardBlock);\n            uint256 _rewardAmount = (_blocks * _pool.rewardPerBlock);\n            _accRewardPerShare += (_calAccPerShare(_rewardAmount, _lpSupply));\n        }\n        _pending = uint256(int256(_calAccumulatedReward(user.amount, _accRewardPerShare)) - user.rewardDebt);\n    }\n\n    function _harvest(uint256 _accRewardPerShare, address _to) internal returns (uint256 _pendingRewardAmount) {\n        UserInfo memory _user = userInfo[msg.sender];\n        int256 accumulatedReward = int256(_calAccumulatedReward(_user.amount, _accRewardPerShare));\n        _pendingRewardAmount = uint256(accumulatedReward - _user.rewardDebt);\n\n        // Effects\n        _user.rewardDebt = accumulatedReward;\n        userInfo[msg.sender] = _user;\n        // Interactions\n        if (_pendingRewardAmount != 0) {\n            REWARD_TOKEN.safeTransfer(_to, _pendingRewardAmount);\n        }\n    }\n\n    function _withdrawAndHarvest(\n        uint256 _tokenId,\n        uint256 _liquidity,\n        uint256 _accRewardPerShare,\n        UserInfo memory _user,\n        address _to\n    ) internal returns (uint256) {\n        int256 accumulatedReward = int256(_calAccumulatedReward(_user.amount, _accRewardPerShare));\n        uint256 _pendingRewardAmount = uint256(accumulatedReward - _user.rewardDebt);\n\n        // Effects\n        _user.amount -= _liquidity;\n        _user.rewardDebt = accumulatedReward - int256(_calAccumulatedReward(_liquidity, _accRewardPerShare));\n\n        userInfo[msg.sender] = _user;\n        userTokenAmount[msg.sender][_tokenId] = 0;\n\n        // Interactions\n        REWARD_TOKEN.safeTransfer(_to, _pendingRewardAmount);\n        return _pendingRewardAmount;\n    }\n\n    function _updatePool(uint256 _lpSupply) internal returns (PoolInfo memory _pool) {\n        _pool = pool;\n        if (block.number > pool.lastRewardBlock) {\n            if (_lpSupply > 0) {\n                uint256 _blocks = block.number - pool.lastRewardBlock;\n                uint256 _rewardAmount = (_blocks * _pool.rewardPerBlock);\n                _pool.accRewardPerShare += uint128(_calAccPerShare(_rewardAmount, _lpSupply));\n            }\n            _pool.lastRewardBlock = uint64(block.number);\n            pool = _pool;\n            emit LogUpdatePool(_pool.lastRewardBlock, _lpSupply, _pool.accRewardPerShare);\n        }\n    }\n\n    function _depositLiquidity(\n        uint256 _tokenId,\n        uint256 _tokenAmount,\n        uint256 _liquidity,\n        uint256 _accRewardPerShare,\n        UserInfo memory _user,\n        bool _negative\n    ) internal {\n        require(_liquidity != 0, \"Farming: no liquidity\");\n\n        int256 _accumulatedReward = int256(_calAccumulatedReward(_liquidity, _accRewardPerShare));\n\n        if (_negative) {\n            totalLiquidity -= _liquidity;\n            _user.amount -= _liquidity;\n            _user.rewardDebt -= _accumulatedReward;\n        } else {\n            totalLiquidity += _liquidity;\n            _user.amount += _liquidity;\n            _user.rewardDebt += _accumulatedReward;\n        }\n\n        userInfo[msg.sender] = _user;\n        userTokenAmount[msg.sender][_tokenId] += _tokenAmount;\n    }\n\n    function _withdrawLiquidity(uint256 _tokenId, uint256 _liquidity, uint256 _accRewardPerShare, UserInfo memory _user)\n        internal\n    {\n        _user.rewardDebt -= int256(_calAccumulatedReward(_liquidity, _accRewardPerShare));\n\n        _user.amount -= _liquidity;\n        totalLiquidity -= _liquidity;\n\n        userInfo[msg.sender] = _user;\n        userTokenAmount[msg.sender][_tokenId] = 0; // withdraw all its token from farming\n    }\n\n    function _calAccumulatedReward(uint256 _amount, uint256 _accRewardPerShare) internal pure returns (uint256) {\n        return (_amount * _accRewardPerShare) / ACC_REWARD_PRECISION;\n    }\n\n    function _calAccPerShare(uint256 _rewardAmount, uint256 _lpSupply) internal pure returns (uint256) {\n        return (_rewardAmount * ACC_REWARD_PRECISION) / _lpSupply;\n    }\n}\n"
    },
    "contracts/farming/DerivedDexLpFarming.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.24;\n\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport \"../interfaces/ITokenTracker.sol\";\nimport \"./BaseDexLpFarming.sol\";\n\n/// @notice The (older) DexLpFarming contract gives out a constant number of REWARD_TOKEN tokens per block.\ncontract DerivedDexLpFarming is Ownable2Step, BaseDexLpFarming {\n    using SafeERC20 for IERC20;\n\n    address public liquidityPool;\n    address public nativeToken;\n\n    ITokenTracker public tokenTracker;\n\n    event TokenTrackerUpdated(ITokenTracker indexed newTokenTracker);\n    event LiquidityPoolUpdated(address indexed newLiquidityPool);\n    event NativeTokenUpdated(address indexed newNativeToken);\n\n    /// @param _rewardToken The REWARD token contract address.\n    constructor(IERC20 _rewardToken, ITokenTracker _tokenTracker, address _liquidityPool, address _nativeToken)\n        BaseDexLpFarming(_rewardToken)\n    {\n        tokenTracker = _tokenTracker;\n        liquidityPool = _liquidityPool;\n        nativeToken = _nativeToken;\n    }\n\n    /// @notice View function to see pending reward on frontend.\n    /// @param _user Address of user.\n    /// @return _pending REWARD_TOKEN reward for a given user.\n    function pendingReward(address _user) external view returns (uint256 _pending) {\n        uint256 _lpSupply = IERC20(nativeToken).balanceOf(liquidityPool);\n        _pending = _pendingReward(_user, _lpSupply);\n    }\n\n    /// @notice Update reward variables of the given pool.\n    /// @return _pool Returns the pool that was updated.\n    function updatePool() public returns (PoolInfo memory _pool) {\n        uint256 lpSupply = IERC20(nativeToken).balanceOf(liquidityPool);\n        _pool = _updatePool(lpSupply);\n    }\n\n    /// @notice Set the new TokenTracker, can only be called by owner.\n    /// @param _tokenTracker The new TokenTracker.\n    function setTokenTracker(ITokenTracker _tokenTracker) external onlyOwner {\n        tokenTracker = _tokenTracker;\n        emit TokenTrackerUpdated(_tokenTracker);\n    }\n\n    /// @notice Set the new TokenTracker, can only be called by owner.\n    /// @param _nativeToken The new TokenTracker.\n    function setNativeToken(address _nativeToken) external onlyOwner {\n        nativeToken = _nativeToken;\n        emit NativeTokenUpdated(_nativeToken);\n    }\n\n    /// @notice Set the new TokenTracker, can only be called by owner.\n    /// @param _liquidityPool The new TokenTracker.\n    function setLiquidityPool(address _liquidityPool) external onlyOwner {\n        liquidityPool = _liquidityPool;\n        emit LiquidityPoolUpdated(_liquidityPool);\n    }\n\n    /// @notice Deposit LP tokens to DexLpFarming for REWARD_TOKEN allocation.\n    /// @param _tokenId LP token id to deposit.\n    function deposit(uint256 _tokenId) external {\n        PoolInfo memory _pool = updatePool();\n        UserInfo memory _user = userInfo[msg.sender];\n\n        uint256[] memory _tokenIds = new uint256[](1);\n        _tokenIds[0] = _tokenId;\n        _deposit(_tokenId, _pool.accRewardPerShare, _user);\n        emit Deposit(msg.sender, _tokenIds);\n    }\n\n    /// @notice Deposit batch LP tokens to DexLpFarming for REWARD_TOKEN allocation.\n    /// @param _tokenIds LP token ids to deposit.\n    function depositBatch(uint256[] memory _tokenIds) external {\n        PoolInfo memory _pool = updatePool();\n        UserInfo memory _user = userInfo[msg.sender];\n\n        // Effects\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n            _deposit(_tokenIds[i], _pool.accRewardPerShare, _user);\n        }\n\n        emit Deposit(msg.sender, _tokenIds);\n    }\n\n    /// @notice Withdraw LP tokens from DexLpFarming.\n    /// @param _tokenId LP token id to withdraw.\n    function withdraw(uint256 _tokenId) external {\n        UserInfo memory _user = userInfo[msg.sender];\n        require(_user.amount != 0, \"Farming: can not withdraw\");\n        PoolInfo memory _pool = updatePool();\n\n        uint256[] memory _tokenIds = new uint256[](1);\n        _tokenIds[0] = _tokenId;\n        _withdraw(_tokenId, _pool.accRewardPerShare, _user);\n        emit Withdraw(msg.sender, _tokenIds);\n    }\n\n    /// @notice Withdraw LP tokens from DexLpFarming.\n    /// @param _tokenIds LP token ids to withdraw.\n    function withdrawBatch(uint256[] memory _tokenIds) external {\n        UserInfo memory _user = userInfo[msg.sender];\n        require(_user.amount != 0, \"Farming: can not withdraw\");\n\n        PoolInfo memory _pool = updatePool();\n\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n            _withdraw(_tokenIds[i], _pool.accRewardPerShare, _user);\n        }\n        emit Withdraw(msg.sender, _tokenIds);\n    }\n\n    /// @notice Harvest proceeds for transaction sender to `to`.\n    /// @param _to Receiver of REWARD_TOKEN rewards.\n    function harvest(address _to) external {\n        PoolInfo memory pool = updatePool();\n        uint256 _pendingRewardAmount = _harvest(pool.accRewardPerShare, _to);\n        emit Harvest(msg.sender, _pendingRewardAmount);\n    }\n\n    /// @notice Withdraw LP tokens from DexLpFarming and harvest proceeds for transaction sender to `_to`.\n    /// @param _tokenId LP token id index to withdraw.\n    function withdrawAndHarvest(uint256 _tokenId, address _to) external {\n        UserInfo memory _user = userInfo[msg.sender];\n        require(_user.amount != 0, \"Farming: can not withdraw\");\n        require(userTokenAmount[msg.sender][_tokenId] != 0, \"Farming: can not withdraw\");\n\n        PoolInfo memory _pool = updatePool();\n\n        uint256 _liquidity = _getLiquidity(_tokenId);\n\n        // Effects\n        uint256 _pendingAmount = _withdrawAndHarvest(_tokenId, _liquidity, _pool.accRewardPerShare, _user, _to);\n\n        // Interactions\n        tokenTracker.transferFrom(address(this), _to, _tokenId);\n\n        uint256[] memory _tokenIds = new uint256[](1);\n        _tokenIds[0] = _tokenId;\n        emit WithdrawAndHarvest(msg.sender, _tokenIds, _pendingAmount);\n    }\n\n    function _deposit(uint256 _tokenId, uint256 _accRewardPerShare, UserInfo memory _user) internal {\n        uint256 _liquidity = _getLiquidity(_tokenId);\n\n        _depositLiquidity(_tokenId, 1, _liquidity, _accRewardPerShare, _user, false);\n\n        // Interactions\n        tokenTracker.transferFrom(msg.sender, address(this), _tokenId);\n    }\n\n    function _withdraw(uint256 _tokenId, uint256 _accRewardPerShare, UserInfo memory _user) internal {\n        require(userTokenAmount[msg.sender][_tokenId] != 0, \"Farming: can not withdraw\");\n        uint256 _liquidity = _getLiquidity(_tokenId);\n\n        _withdrawLiquidity(_tokenId, _liquidity, _accRewardPerShare, _user);\n\n        // Interactions\n        tokenTracker.transferFrom(address(this), msg.sender, _tokenId);\n    }\n\n    function _getLiquidity(uint256 _tokenId) internal view returns (uint256) {\n        (,,,,,,, uint256 _liquidity,,,,) = tokenTracker.positions(_tokenId);\n\n        return _liquidity;\n    }\n}\n"
    },
    "contracts/farming/DerivedFarmingERC1155.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.24;\n// todo verify dex lp farming of erc1155 in arbitrum goerli\n\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport \"../interfaces/ILBPair.sol\";\nimport \"./BaseDexLpFarming.sol\";\nimport {PackedUint128Math} from \"../libraries/PackedUint128Math.sol\";\nimport {BinHelper} from \"../libraries/BinHelper.sol\";\n\n/// @notice The (older) DexLpFarming contract gives out a constant number of REWARD_TOKEN tokens per block.\ncontract DerivedDexLpFarmingERC1155 is Ownable2Step, BaseDexLpFarming {\n    using SafeERC20 for IERC20;\n    using PackedUint128Math for bytes32;\n    using PackedUint128Math for uint128;\n    using BinHelper for bytes32;\n\n    ILBPair public LBPair;\n\n    /// @notice liquidity amount of user corresponds to token id in pool.\n    mapping(address => mapping(uint256 => uint256)) public liqudityOfId;\n    /// @notice liquidity amount of tokenX user deposited in LBPair pool corresponds to Token Id.\n    mapping(address => mapping(uint256 => uint256)) public liquidityAmountX;\n\n    event LBPairUpdated(ILBPair indexed newLBPair);\n\n    /// @param _rewardToken The REWARD token contract address.\n    constructor(IERC20 _rewardToken, ILBPair _LBPair) BaseDexLpFarming(_rewardToken) {\n        LBPair = _LBPair;\n    }\n\n    /// @notice View function to see pending reward on frontend.\n    /// @param _user Address of user.\n    /// @return _pending REWARD_TOKEN reward for a given user.\n    function pendingReward(address _user) external view returns (uint256 _pending) {\n        (, uint256 _lpSupply) = LBPair.getReserves();\n        _pending = _pendingReward(_user, _lpSupply);\n    }\n\n    /// @notice Update reward variables of the given pool.\n    /// @return _pool Returns the pool that was updated.\n    function updatePool() public returns (PoolInfo memory _pool) {\n        (, uint256 lpSupply) = LBPair.getReserves();\n        _pool = _updatePool(lpSupply);\n    }\n\n    /// @notice Set the new Lbpair, can only be called by owner.\n    /// @param _lbPair The new Lbpair\n    function setLBPair(ILBPair _lbPair) external onlyOwner {\n        LBPair = _lbPair;\n        emit LBPairUpdated(_lbPair);\n    }\n\n    /// @notice Deposit batch LP tokens to DexLpFarming for REWARD_TOKEN allocation.\n    /// @param _tokenIds LP token ids to deposit.\n    /// @param _tokenAmounts LP token amount to deposit.\n    function depositBatch(uint256[] memory _tokenIds, uint256[] memory _tokenAmounts) external {\n        PoolInfo memory _pool = updatePool();\n        UserInfo memory _user = userInfo[msg.sender];\n\n        // Effects\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n            require(_tokenAmounts[i] != 0, \"Farming: zero token amount\");\n            (uint256 _liquidityX, uint256 _liquidity) = _getLiquidityAmount(_tokenIds[i], msg.sender);\n            liquidityAmountX[msg.sender][_tokenIds[i]] = _liquidityX;\n            bool neg;\n            uint256 _liquidityDifference;\n\n            if (_liquidity > liqudityOfId[msg.sender][_tokenIds[i]]) {\n                _liquidityDifference = _liquidity - liqudityOfId[msg.sender][_tokenIds[i]];\n            } else {\n                _liquidityDifference = liqudityOfId[msg.sender][_tokenIds[i]] - _liquidity;\n                neg = true;\n            }\n\n            liqudityOfId[msg.sender][_tokenIds[i]] = _liquidity;\n            _depositLiquidity(_tokenIds[i], _tokenAmounts[i], _liquidityDifference, _pool.accRewardPerShare, _user, neg);\n        }\n\n        // Interactions\n        LBPair.batchTransferFrom(msg.sender, address(this), _tokenIds, _tokenAmounts);\n\n        emit Deposit(msg.sender, _tokenIds);\n    }\n\n    /// @notice Withdraw LP tokens from DexLpFarming.\n    /// @param _tokenIds LP token ids to withdraw.\n    function withdrawBatch(uint256[] memory _tokenIds) external {\n        UserInfo memory _user = userInfo[msg.sender];\n        require(_user.amount != 0, \"Farming: can not withdraw\");\n\n        PoolInfo memory _pool = updatePool();\n        uint256[] memory _tokensAmount = new uint256[](_tokenIds.length);\n\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n            uint256 _amount = userTokenAmount[msg.sender][_tokenIds[i]];\n            require(_amount != 0, \"Farming: no token available\");\n            _tokensAmount[i] = _amount;\n\n            liqudityOfId[msg.sender][_tokenIds[i]] = 0;\n            (, uint256 _liquidity) = _getLiquidityAmount(_tokenIds[i], msg.sender);\n\n            _withdrawLiquidity(_tokenIds[i], _liquidity, _pool.accRewardPerShare, _user);\n        }\n\n        LBPair.batchTransferFrom(address(this), msg.sender, _tokenIds, _tokensAmount);\n\n        emit Withdraw(msg.sender, _tokenIds);\n    }\n\n    /// @notice Harvest proceeds for transaction sender to `to`.\n    /// @param to Receiver of REWARD_TOKEN rewards.\n    function harvest(address to) external {\n        PoolInfo memory pool = updatePool();\n        uint256 _pendingRewardAmount = _harvest(pool.accRewardPerShare, to);\n        emit Harvest(msg.sender, _pendingRewardAmount);\n    }\n\n    /// @notice Withdraw LP tokens from DexLpFarming and harvest proceeds for transaction sender to `to`.\n    /// @param _tokenIds LP token ids to withdraw.\n    function withdrawAndHarvest(uint256[] memory _tokenIds, address _to) external {\n        UserInfo memory _user = userInfo[msg.sender];\n        require(_user.amount != 0, \"Farming: can not withdraw\");\n\n        PoolInfo memory pool = updatePool();\n\n        uint256[] memory _tokensAmount = new uint256[](_tokenIds.length);\n        uint256 _totalPendingAmount;\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n            uint256 _amount = userTokenAmount[msg.sender][_tokenIds[i]];\n            require(_amount != 0, \"Farming: token not deposited\");\n            _tokensAmount[i] = _amount;\n\n            liqudityOfId[msg.sender][_tokenIds[i]] = 0;\n            (, uint256 _liquidity) = _getLiquidityAmount(_tokenIds[i], msg.sender);\n\n            _totalPendingAmount += _withdrawAndHarvest(_tokenIds[i], _liquidity, pool.accRewardPerShare, _user, _to);\n        }\n        // Interactions\n        LBPair.batchTransferFrom(address(this), _to, _tokenIds, _tokensAmount);\n        emit WithdrawAndHarvest(msg.sender, _tokenIds, _totalPendingAmount);\n    }\n\n    function getLiquidityIds(uint256[] calldata _tokenIds) external view returns (uint256[] memory tokenIds) {\n        uint256 liquidity;\n        uint256 liquidityX;\n        uint256 idIndex;\n        tokenIds = new uint256[](_tokenIds.length);\n        for (uint256 index; index < _tokenIds.length; ++index) {\n            (liquidityX, liquidity) = _getLiquidity(_tokenIds[index]);\n            if (liquidity != 0 || liquidityX != 0) {\n                tokenIds[idIndex] = _tokenIds[index];\n                ++idIndex;\n            }\n        }\n    }\n\n    function _getLiquidity(uint256 _tokenId) internal view returns (uint256, uint256) {\n        return LBPair.getBin(uint24(_tokenId));\n    }\n\n    function _getLiquidityAmount(uint256 _id, address _user)\n        internal\n        view\n        returns (uint256 _liquidityX, uint256 _liquidityY)\n    {\n        (uint128 reserveX, uint128 reserveY) = LBPair.getBin(uint24(_id));\n        uint256 amountInBin = LBPair.balanceOf(_user, _id);\n        bytes32 binReserves = reserveX.encode(reserveY);\n        uint256 supply = LBPair.totalSupply(_id);\n\n        bytes32 amountsOutFromBin = binReserves.getAmountOutOfBin(amountInBin, supply);\n        (_liquidityX, _liquidityY) = amountsOutFromBin.decode();\n    }\n}\n"
    },
    "contracts/farming/DexLpFarming.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\n/// @notice The (older) DexLpFarming contract gives out a constant number of REWARD_TOKEN tokens per block.\ncontract DexLpFarming is Ownable2Step {\n    using SafeERC20 for IERC20;\n\n    /// @notice Info of each DexLpFarming user.\n    /// `amount` LP token amount the user has provided.\n    /// `rewardDebt` The amount of reward token entitled to the user.\n    struct UserInfo {\n        uint256 amount;\n        int256 rewardDebt;\n    }\n\n    /// @notice Info of each DexLpFarming pool.\n    /// `allocPoint` The amount of allocation points assigned to the pool.\n    /// Also known as the amount of reward token to distribute per block.\n    struct PoolInfo {\n        uint128 accRewardPerShare;\n        uint64 lastRewardBlock;\n        uint64 allocPoint;\n    }\n\n    /// @notice Address of reward token contract.\n    IERC20 public immutable REWARD_TOKEN;\n\n    /// @notice Info of each DexLpFarming pool.\n    PoolInfo[] public poolInfo;\n    /// @notice Address of the LP token for each DexLpFarming pool.\n    IERC721[] public lpToken;\n\n    /// @notice Info of each user that stakes LP tokens.\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n    /// @notice token ids of user in pool.\n    mapping(uint256 => mapping(address => uint256[])) public userToken;\n    /// @dev Total allocation points. Must be the sum of all allocation points in all pools.\n    uint256 public totalAllocPoint;\n\n    uint256 public rewardPerBlock;\n    uint256 public currentEpoch;\n    uint256 private constant ACC_REWARD_PRECISION = 1e18;\n\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount, address indexed to);\n    event Harvest(address indexed user, uint256 indexed pid, uint256 amount);\n    event LogPoolAddition(uint256 indexed pid, uint256 allocPoint, IERC721 indexed lpToken);\n    event LogSetPool(uint256 indexed pid, uint256 allocPoint);\n    event LogUpdatePool(uint256 indexed pid, uint64 lastRewardBlock, uint256 lpSupply, uint256 accRewardPerShare);\n    event LogRewardPerBlock(uint256 rewardPerBlock, uint256 indexed currentEpoch, uint256 amount);\n\n    /// @param _rewardToken The REWARD token contract address.\n    constructor(IERC20 _rewardToken) Ownable(msg.sender) {\n        REWARD_TOKEN = _rewardToken;\n    }\n\n    /// @notice Returns the number of DexLpFarming pools.\n    function poolLength() public view returns (uint256 pools) {\n        pools = poolInfo.length;\n    }\n\n    /// @notice Returns the number of user tokens ids in the pool.\n    function userTokenIds(uint256 pid, address user) public view returns (uint256[] memory) {\n        return userToken[pid][user];\n    }\n\n    /// @notice Add a new LP to the pool. Can only be called by the owner.\n    /// DO NOT add the same LP token more than once. Rewards will be messed up if you do.\n    /// @param allocPoint AP of the new pool.\n    /// @param _lpToken Address of the LP ERC-20 token.\n    function add(uint256 allocPoint, IERC721 _lpToken) public onlyOwner {\n        totalAllocPoint += allocPoint;\n        lpToken.push(_lpToken);\n\n        poolInfo.push(\n            PoolInfo({allocPoint: uint64(allocPoint), lastRewardBlock: uint64(block.number), accRewardPerShare: 0})\n        );\n        emit LogPoolAddition(lpToken.length - 1, allocPoint, _lpToken);\n    }\n\n    /// @notice Update the given pool's reward token allocation point. Can only be called by the owner.\n    /// @param _pid The index of the pool. See `poolInfo`.\n    /// @param _allocPoint New AP of the pool.\n    function set(uint256 _pid, uint256 _allocPoint) public onlyOwner {\n        uint256 _totalAllocPoint = totalAllocPoint;\n        _totalAllocPoint += _allocPoint;\n        _totalAllocPoint -= poolInfo[_pid].allocPoint;\n        totalAllocPoint = _totalAllocPoint;\n        poolInfo[_pid].allocPoint = uint64(_allocPoint);\n        emit LogSetPool(_pid, _allocPoint);\n    }\n\n    /// @notice Sets the reward per second to be distributed. Can only be called by the owner.\n    /// @param _rewardPerBlock The amount of reward token to be distributed per block number.\n    /// @param _user address from which reward is to be distributed.\n    /// @param _amount The amount of reward token to be deposit in dexLpFarmin.\n    function setRewardPerBlock(uint256 _rewardPerBlock, address _user, uint256 _amount) public onlyOwner {\n        rewardPerBlock = _rewardPerBlock;\n        ++currentEpoch;\n        REWARD_TOKEN.safeTransferFrom(_user, address(this), _amount);\n        emit LogRewardPerBlock(_rewardPerBlock, currentEpoch, _amount);\n    }\n\n    /// @notice View function to see pending reward on frontend.\n    /// @param _pid The index of the pool. See `poolInfo`.\n    /// @param _user Address of user.\n    /// @return pending REWARD_TOKEN reward for a given user.\n    function pendingReward(uint256 _pid, address _user) external view returns (uint256 pending) {\n        PoolInfo memory pool = poolInfo[_pid];\n        UserInfo memory user = userInfo[_pid][_user];\n        uint256 accRewardPerShare = pool.accRewardPerShare;\n        uint256 lpSupply = lpToken[_pid].balanceOf(address(this));\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\n            uint256 blocks = block.number - (pool.lastRewardBlock);\n            uint256 rewardAmount = (blocks * (rewardPerBlock) * (pool.allocPoint)) / totalAllocPoint;\n            accRewardPerShare += ((rewardAmount * (ACC_REWARD_PRECISION)) / lpSupply);\n        }\n        pending = uint256(int256((user.amount * accRewardPerShare) / ACC_REWARD_PRECISION) - user.rewardDebt);\n    }\n\n    /// @notice Update reward variables of the given pool.\n    /// @param pid The index of the pool. See `poolInfo`.\n    /// @return pool Returns the pool that was updated.\n    function updatePool(uint256 pid) public returns (PoolInfo memory pool) {\n        pool = poolInfo[pid];\n        if (block.number > pool.lastRewardBlock) {\n            uint256 lpSupply = lpToken[pid].balanceOf(address(this));\n            if (lpSupply > 0) {\n                uint256 blocks = block.number - pool.lastRewardBlock;\n                uint256 rewardAmount = (blocks * rewardPerBlock * pool.allocPoint) / totalAllocPoint;\n                pool.accRewardPerShare += uint128((rewardAmount * ACC_REWARD_PRECISION) / lpSupply);\n            }\n            pool.lastRewardBlock = uint64(block.number);\n            poolInfo[pid] = pool;\n            emit LogUpdatePool(pid, pool.lastRewardBlock, lpSupply, pool.accRewardPerShare);\n        }\n    }\n\n    /// @notice Deposit LP tokens to DexLpFarming for REWARD_TOKEN allocation.\n    /// @param pid The index of the pool. See `poolInfo`.\n    /// @param id LP token id to deposit.\n    function deposit(uint256 pid, uint256 id) public {\n        PoolInfo memory pool = updatePool(pid);\n        UserInfo memory user = userInfo[pid][msg.sender];\n\n        _deposit(pid, id, user, pool.accRewardPerShare);\n    }\n\n    /// @notice Deposit batch LP tokens to DexLpFarming for REWARD_TOKEN allocation.\n    /// @param pid The index of the pool. See `poolInfo`.\n    /// @param id LP token ids to deposit.\n    function depositBatch(uint256 pid, uint256[] memory id) public {\n        PoolInfo memory pool = updatePool(pid);\n        UserInfo memory user = userInfo[pid][msg.sender];\n\n        // Effects\n        for (uint256 i = 0; i < id.length; i++) {\n            _deposit(pid, id[i], user, pool.accRewardPerShare);\n        }\n    }\n\n    /// @notice Withdraw LP tokens from DexLpFarming.\n    /// @param pid The index of the pool. See `poolInfo`.\n    /// @param id LP token ids to withdraw.\n    function withdrawBatch(uint256 pid, uint256[] memory id) public {\n        PoolInfo memory pool = updatePool(pid);\n        UserInfo memory user = userInfo[pid][msg.sender];\n        require(user.amount != 0, \"DexLpFarming: can not withdraw\");\n\n        uint256[] memory _userTokenIds = userToken[pid][msg.sender];\n\n        for (uint256 i = 0; i < id.length; i++) {\n            _withdraw(pid, id[i], user, pool.accRewardPerShare, _userTokenIds);\n        }\n    }\n\n    /// @notice Withdraw LP tokens from DexLpFarming.\n    /// @param pid The index of the pool. See `poolInfo`.\n    /// @param id LP token id to withdraw.\n    function withdraw(uint256 pid, uint256 id) public {\n        PoolInfo memory pool = updatePool(pid);\n        UserInfo memory user = userInfo[pid][msg.sender];\n        require(user.amount != 0, \"DexLpFarming: can not withdraw\");\n\n        uint256[] memory _userTokenIds = userToken[pid][msg.sender];\n\n        _withdraw(pid, id, user, pool.accRewardPerShare, _userTokenIds);\n    }\n\n    /// @notice Harvest proceeds for transaction sender to `to`.\n    /// @param pid The index of the pool. See `poolInfo`.\n    /// @param to Receiver of REWARD_TOKEN rewards.\n    function harvest(uint256 pid, address to) public {\n        PoolInfo memory pool = updatePool(pid);\n        UserInfo memory user = userInfo[pid][msg.sender];\n        int256 accumulatedReward = int256((user.amount * pool.accRewardPerShare) / ACC_REWARD_PRECISION);\n        uint256 _pendingReward = uint256(accumulatedReward - user.rewardDebt);\n\n        // Effects\n        user.rewardDebt = accumulatedReward;\n        userInfo[pid][msg.sender] = user;\n        // Interactions\n        if (_pendingReward != 0) {\n            REWARD_TOKEN.safeTransfer(to, _pendingReward);\n        }\n\n        emit Harvest(msg.sender, pid, _pendingReward);\n    }\n\n    /// @notice Withdraw LP tokens from DexLpFarming and harvest proceeds for transaction sender to `to`.\n    /// @param pid The index of the pool. See `poolInfo`.\n    /// @param id LP token id to withdraw.\n    function withdrawAndHarvest(uint256 pid, uint256 id, address to) public {\n        PoolInfo memory pool = updatePool(pid);\n        UserInfo memory user = userInfo[pid][msg.sender];\n        require(user.amount != 0, \"DexLpFarming: can not withdraw\");\n\n        int256 accumulatedReward = int256((user.amount * pool.accRewardPerShare) / ACC_REWARD_PRECISION);\n        uint256 _pendingReward = uint256(accumulatedReward - user.rewardDebt);\n\n        // Effects\n        user.rewardDebt = accumulatedReward - int256((pool.accRewardPerShare) / ACC_REWARD_PRECISION);\n        user.amount -= 1;\n\n        userInfo[pid][msg.sender] = user;\n        // Interactions\n        REWARD_TOKEN.safeTransfer(to, _pendingReward);\n\n        lpToken[pid].transferFrom(address(this), to, id);\n\n        emit Withdraw(msg.sender, pid, id);\n        emit Harvest(msg.sender, pid, _pendingReward);\n    }\n\n    /// @notice Withdraw without caring about rewards. EMERGENCY ONLY.\n    /// @param pid The index of the pool. See `poolInfo`.\n    /// @param to Receiver of the LP tokens.\n    function emergencyWithdraw(uint256 pid, address to) public {\n        UserInfo memory user = userInfo[pid][msg.sender];\n        uint256[] memory _userTokenIds = userToken[pid][msg.sender];\n        uint256 amount = user.amount;\n\n        // Note: transfer can fail or succeed if `amount` is zero.\n        for (uint256 i = 0; i < _userTokenIds.length; i++) {\n            lpToken[pid].transferFrom(address(this), to, _userTokenIds[i]);\n        }\n\n        delete userInfo[pid][msg.sender];\n        delete userToken[pid][msg.sender];\n        emit EmergencyWithdraw(msg.sender, pid, amount, to);\n    }\n\n    function _deposit(uint256 _pid, uint256 _id, UserInfo memory _user, uint256 _accRewardPerShare) internal {\n        _user.amount += 1;\n        userToken[_pid][msg.sender].push(_id);\n        _user.rewardDebt += int256(_accRewardPerShare / ACC_REWARD_PRECISION);\n        userInfo[_pid][msg.sender] = _user;\n\n        // Interactions\n        lpToken[_pid].transferFrom(msg.sender, address(this), _id);\n\n        emit Deposit(msg.sender, _pid, _id);\n    }\n\n    function _withdraw(\n        uint256 _pid,\n        uint256 _id,\n        UserInfo memory _user,\n        uint256 _accRewardPerShare,\n        uint256[] memory _userTokenIds\n    ) internal {\n        _user.rewardDebt -= int256((_accRewardPerShare) / ACC_REWARD_PRECISION);\n        for (uint256 i = 0; i < _userTokenIds.length; i++) {\n            if (_userTokenIds[i] == _id) {\n                _userTokenIds[i] = _userTokenIds[_userTokenIds.length - 1];\n                break;\n            }\n        }\n\n        _user.amount -= 1;\n        if (_user.amount != 0) {\n            userToken[_pid][msg.sender] = _userTokenIds;\n        } else {\n            delete userToken[_pid][msg.sender];\n        }\n        userInfo[_pid][msg.sender] = _user;\n\n        // Interactions\n        lpToken[_pid].transferFrom(address(this), msg.sender, _id);\n\n        emit Withdraw(msg.sender, _pid, _id);\n    }\n}\n"
    },
    "contracts/interfaces/IGaugeController.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.24;\n\ninterface IGaugeController {\n    function updateReward(address pool, address user, uint256 amount, bool increase) external;\n\n    function decreaseRewardAndClaim(address pool, uint256 amount, address user) external;\n}\n"
    },
    "contracts/interfaces/ILBPair.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.24;\n\ninterface ILBPair {\n    function batchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts) external;\n\n    function getBin(uint24 id) external view returns (uint128, uint128);\n\n    function getReserves() external view returns (uint128, uint128);\n\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    function totalSupply(uint256 id) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ISmartWalletChecker.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.24;\n\ninterface ISmartWalletChecker {\n    function check(address user) external returns (bool);\n}\n"
    },
    "contracts/interfaces/ISynthrNFT.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.24;\n\ninterface ISynthrNFT {\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function lockAmount(uint256 _tokenId) external view returns (uint256);\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function safeMint(address to, uint256 lpAmount) external returns (uint256);\n    function safeMintBatch(address[] calldata _to, uint256[] calldata _lpAmount) external;\n}\n"
    },
    "contracts/interfaces/ITokenTracker.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.24;\n\ninterface ITokenTracker {\n    function positions(uint256 tokenId)\n        external\n        view\n        returns (\n            uint96 nonce,\n            address operator,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    function transferFrom(address from, address to, uint256 tokenId) external;\n}\n"
    },
    "contracts/interfaces/IVoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.24;\n\ninterface IVoter {\n    error AlreadyVotedOrDeposited();\n    error DistributeWindow();\n    error PoolAlreadyKilled();\n    error PoolAlreadyRevived();\n    error PoolNotAlive(uint256 _pool);\n    error MaximumVotingNumberTooLow();\n    error NonZeroVotes();\n    error NotGovernor();\n    error NotEmergencyCouncil();\n    error NotWhitelistedUser();\n    error SameValue();\n    error TooManyPools();\n    error UnequalLengths();\n    error ZeroBalance();\n    error ZeroAddress();\n\n    event PoolKilled(uint256 indexed gauge);\n    event PoolRevived(uint256 indexed gauge);\n    event PoolSet(uint256 indexed pool, address indexed governor);\n    event VotingEscrowChanged(address indexed newVotingEscrow);\n\n    event Voted(\n        address indexed voter,\n        uint256 indexed pool,\n        address indexed user,\n        uint256 weight,\n        uint256 totalWeight,\n        uint256 timestamp\n    );\n    event Abstained(\n        address indexed voter,\n        uint256 indexed pool,\n        address indexed user,\n        uint256 weight,\n        uint256 totalWeight,\n        uint256 timestamp\n    );\n    event WhitelistUser(address indexed whitelister, address[] indexed user, bool[] indexed _bool);\n\n    /// @notice Called by users to vote for pools. Votes distributed proportionally based on weights.\n    ///         Can only vote for gauges that have not been killed.\n    /// @dev Weights are distributed proportional to the sum of the weights in the array.\n    ///      Throws if length of _poolVote and _weights do not match.\n    /// @param _poolVote    Array of pools you are voting for.\n    /// @param _weights     Weights of pools.\n    function vote(uint256[] calldata _poolVote, uint256[] calldata _weights) external;\n\n    /// @notice Called by users to update voting balances in voting rewards contracts.\n    function poke() external;\n\n    /// @notice Called by users to reset voting state.\n    ///         Cannot reset in the same epoch that you voted in.\n    function reset() external;\n\n    /// @notice Set new governor.\n    /// @dev Throws if not called by governor.\n    /// @param _governor .\n    function setGovernor(address _governor) external;\n\n    /// @notice Set new emergency council.\n    /// @dev Throws if not called by emergency council.\n    /// @param _emergencyCouncil .\n    function setEmergencyCouncil(address _emergencyCouncil) external;\n\n    /// @notice Set maximum number of gauges that can be voted for.\n    /// @dev Throws if not called by governor.\n    ///      Throws if _maxVotingNum is too low.\n    ///      Throws if the values are the same.\n    /// @param _maxVotingNum .\n    function setMaxVotingNum(uint256 _maxVotingNum) external;\n\n    /// @notice Whitelist (or unwhitelist) user for voting in last hour prior to epoch flip.\n    /// @dev Throws if not called by governor.\n    ///      Throws if already whitelisted.\n    /// @param _user .\n    /// @param _bool .\n    function whitelistUser(address[] calldata _user, bool[] calldata _bool) external;\n}\n"
    },
    "contracts/interfaces/IVotingEscrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.24;\n\ninterface IVotingEscrow {\n    function token() external view returns (address);\n\n    function balanceOf(address _user, uint256 _t) external view returns (uint256);\n}\n"
    },
    "contracts/libraries/BinHelper.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.24;\n\nimport {PackedUint128Math} from \"./PackedUint128Math.sol\";\nimport {Uint256x256Math} from \"./Uint256x256Math.sol\";\n\n/**\n * @title Liquidity Book Bin Helper Library\n * @author Trader Joe\n * @notice This library contains functions to help interaction with bins.\n */\nlibrary BinHelper {\n    using Uint256x256Math for uint256;\n    using PackedUint128Math for bytes32;\n    using PackedUint128Math for uint128;\n\n    error BinHelper__CompositionFactorFlawed(uint24 id);\n    error BinHelper__LiquidityOverflow();\n\n    /**\n     * @dev Returns the amount of tokens that will be received when burning the given amount of liquidity\n     * @param binReserves The reserves of the bin\n     * @param amountToBurn The amount of liquidity to burn\n     * @param totalSupply The total supply of the liquidity book\n     * @return amountsOut The encoded amount of tokens that will be received\n     */\n    function getAmountOutOfBin(bytes32 binReserves, uint256 amountToBurn, uint256 totalSupply)\n        internal\n        pure\n        returns (bytes32 amountsOut)\n    {\n        (uint128 binReserveX, uint128 binReserveY) = binReserves.decode();\n\n        uint128 amountXOutFromBin;\n        uint128 amountYOutFromBin;\n\n        if (binReserveX > 0) {\n            amountXOutFromBin = uint128(amountToBurn.mulDivRoundDown(binReserveX, totalSupply));\n        }\n\n        if (binReserveY > 0) {\n            amountYOutFromBin = uint128(amountToBurn.mulDivRoundDown(binReserveY, totalSupply));\n        }\n\n        amountsOut = amountXOutFromBin.encode(amountYOutFromBin);\n    }\n}\n"
    },
    "contracts/libraries/PackedUint128Math.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.24;\n\n/**\n * @title Liquidity Book Packed Uint128 Math Library\n * @author Trader Joe\n * @notice This library contains functions to encode and decode two uint128 into a single bytes32\n * and interact with the encoded bytes32.\n */\nlibrary PackedUint128Math {\n    error PackedUint128Math__AddOverflow();\n    error PackedUint128Math__SubUnderflow();\n    error PackedUint128Math__MultiplierTooLarge();\n\n    uint256 private constant OFFSET = 128;\n    uint256 private constant MASK_128 = 0xffffffffffffffffffffffffffffffff;\n    uint256 private constant MASK_128_PLUS_ONE = MASK_128 + 1;\n\n    /**\n     * @dev Encodes two uint128 into a single bytes32\n     * @param x1 The first uint128\n     * @param x2 The second uint128\n     * @return z The encoded bytes32 as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     */\n    function encode(uint128 x1, uint128 x2) internal pure returns (bytes32 z) {\n        assembly {\n            z := or(and(x1, MASK_128), shl(OFFSET, x2))\n        }\n    }\n\n    /**\n     * @dev Encodes a uint128 into a single bytes32 as the first uint128\n     * @param x1 The uint128\n     * @return z The encoded bytes32 as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: empty\n     */\n    function encodeFirst(uint128 x1) internal pure returns (bytes32 z) {\n        assembly {\n            z := and(x1, MASK_128)\n        }\n    }\n\n    /**\n     * @dev Encodes a uint128 into a single bytes32 as the second uint128\n     * @param x2 The uint128\n     * @return z The encoded bytes32 as follows:\n     * [0 - 128[: empty\n     * [128 - 256[: x2\n     */\n    function encodeSecond(uint128 x2) internal pure returns (bytes32 z) {\n        assembly {\n            z := shl(OFFSET, x2)\n        }\n    }\n\n    /**\n     * @dev Encodes a uint128 into a single bytes32 as the first or second uint128\n     * @param x The uint128\n     * @param first Whether to encode as the first or second uint128\n     * @return z The encoded bytes32 as follows:\n     * if first:\n     * [0 - 128[: x\n     * [128 - 256[: empty\n     * else:\n     * [0 - 128[: empty\n     * [128 - 256[: x\n     */\n    function encode(uint128 x, bool first) internal pure returns (bytes32 z) {\n        return first ? encodeFirst(x) : encodeSecond(x);\n    }\n\n    /**\n     * @dev Decodes a bytes32 into two uint128\n     * @param z The encoded bytes32 as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @return x1 The first uint128\n     * @return x2 The second uint128\n     */\n    function decode(bytes32 z) internal pure returns (uint128 x1, uint128 x2) {\n        assembly {\n            x1 := and(z, MASK_128)\n            x2 := shr(OFFSET, z)\n        }\n    }\n\n    /**\n     * @dev Decodes a bytes32 into a uint128 as the first uint128\n     * @param z The encoded bytes32 as follows:\n     * [0 - 128[: x\n     * [128 - 256[: any\n     * @return x The first uint128\n     */\n    function decodeX(bytes32 z) internal pure returns (uint128 x) {\n        assembly {\n            x := and(z, MASK_128)\n        }\n    }\n\n    /**\n     * @dev Decodes a bytes32 into a uint128 as the second uint128\n     * @param z The encoded bytes32 as follows:\n     * [0 - 128[: any\n     * [128 - 256[: y\n     * @return y The second uint128\n     */\n    function decodeY(bytes32 z) internal pure returns (uint128 y) {\n        assembly {\n            y := shr(OFFSET, z)\n        }\n    }\n\n    /**\n     * @dev Decodes a bytes32 into a uint128 as the first or second uint128\n     * @param z The encoded bytes32 as follows:\n     * if first:\n     * [0 - 128[: x1\n     * [128 - 256[: empty\n     * else:\n     * [0 - 128[: empty\n     * [128 - 256[: x2\n     * @param first Whether to decode as the first or second uint128\n     * @return x The decoded uint128\n     */\n    function decode(bytes32 z, bool first) internal pure returns (uint128 x) {\n        return first ? decodeX(z) : decodeY(z);\n    }\n}\n"
    },
    "contracts/libraries/Time.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.24;\n\nlibrary Time {\n    uint256 internal constant WEEK = 7 days;\n\n    /// @dev Returns start of epoch based on current timestamp\n    function epochStart(uint256 timestamp) internal pure returns (uint256) {\n        unchecked {\n            return timestamp - (timestamp % WEEK);\n        }\n    }\n\n    /// @dev Returns start of next epoch / end of current epoch\n    function epochNext(uint256 timestamp) internal pure returns (uint256) {\n        unchecked {\n            return timestamp - (timestamp % WEEK) + WEEK;\n        }\n    }\n\n    /// @dev Returns start of voting window\n    function epochVoteStart(uint256 timestamp) internal pure returns (uint256) {\n        unchecked {\n            return timestamp - (timestamp % WEEK) + 1 hours;\n        }\n    }\n\n    /// @dev Returns end of voting window / beginning of unrestricted voting window\n    function epochVoteEnd(uint256 timestamp) internal pure returns (uint256) {\n        unchecked {\n            return timestamp - (timestamp % WEEK) + WEEK - 1 hours;\n        }\n    }\n}\n"
    },
    "contracts/libraries/Uint256x256Math.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.24;\n\n/**\n * @title Liquidity Book Uint256x256 Math Library\n * @author Trader Joe\n * @notice Helper contract used for full precision calculations\n */\nlibrary Uint256x256Math {\n    error Uint256x256Math__MulShiftOverflow();\n    error Uint256x256Math__MulDivOverflow();\n\n    /**\n     * @notice Calculates floor(x*y/denominator) with full precision\n     * The result will be rounded down\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The denominator cannot be zero\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @param denominator The divisor as an uint256\n     * @return result The result as an uint256\n     */\n    function mulDivRoundDown(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        (uint256 prod0, uint256 prod1) = _getMulProds(x, y);\n\n        return _getEndOfDivRoundDown(x, y, denominator, prod0, prod1);\n    }\n\n    /**\n     * @notice Calculates ceil(x*y/denominator) with full precision\n     * The result will be rounded up\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The denominator cannot be zero\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @param denominator The divisor as an uint256\n     * @return result The result as an uint256\n     */\n    function mulDivRoundUp(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        result = mulDivRoundDown(x, y, denominator);\n        if (mulmod(x, y, denominator) != 0) result += 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / 2**offset) with full precision\n     * The result will be rounded down\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The offset needs to be strictly lower than 256\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @param offset The offset as an uint256, can't be greater than 256\n     * @return result The result as an uint256\n     */\n    function mulShiftRoundDown(uint256 x, uint256 y, uint8 offset) internal pure returns (uint256 result) {\n        (uint256 prod0, uint256 prod1) = _getMulProds(x, y);\n\n        if (prod0 != 0) result = prod0 >> offset;\n        if (prod1 != 0) {\n            // Make sure the result is less than 2^256.\n            if (prod1 >= 1 << offset) revert Uint256x256Math__MulShiftOverflow();\n\n            unchecked {\n                result += prod1 << (256 - offset);\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates floor(x * y / 2**offset) with full precision\n     * The result will be rounded down\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The offset needs to be strictly lower than 256\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @param offset The offset as an uint256, can't be greater than 256\n     * @return result The result as an uint256\n     */\n    function mulShiftRoundUp(uint256 x, uint256 y, uint8 offset) internal pure returns (uint256 result) {\n        result = mulShiftRoundDown(x, y, offset);\n        if (mulmod(x, y, 1 << offset) != 0) result += 1;\n    }\n\n    /**\n     * @notice Calculates floor(x << offset / y) with full precision\n     * The result will be rounded down\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The offset needs to be strictly lower than 256\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param offset The number of bit to shift x as an uint256\n     * @param denominator The divisor as an uint256\n     * @return result The result as an uint256\n     */\n    function shiftDivRoundDown(uint256 x, uint8 offset, uint256 denominator) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n\n        prod0 = x << offset; // Least significant 256 bits of the product\n        unchecked {\n            prod1 = x >> (256 - offset); // Most significant 256 bits of the product\n        }\n\n        return _getEndOfDivRoundDown(x, 1 << offset, denominator, prod0, prod1);\n    }\n\n    /**\n     * @notice Calculates ceil(x << offset / y) with full precision\n     * The result will be rounded up\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The offset needs to be strictly lower than 256\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param offset The number of bit to shift x as an uint256\n     * @param denominator The divisor as an uint256\n     * @return result The result as an uint256\n     */\n    function shiftDivRoundUp(uint256 x, uint8 offset, uint256 denominator) internal pure returns (uint256 result) {\n        result = shiftDivRoundDown(x, offset, denominator);\n        if (mulmod(x, 1 << offset, denominator) != 0) result += 1;\n    }\n\n    /**\n     * @notice Helper function to return the result of `x * y` as 2 uint256\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @return prod0 The least significant 256 bits of the product\n     * @return prod1 The most significant 256 bits of the product\n     */\n    function _getMulProds(uint256 x, uint256 y) private pure returns (uint256 prod0, uint256 prod1) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n    }\n\n    /**\n     * @notice Helper function to return the result of `x * y / denominator` with full precision\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @param denominator The divisor as an uint256\n     * @param prod0 The least significant 256 bits of the product\n     * @param prod1 The most significant 256 bits of the product\n     * @return result The result as an uint256\n     */\n    function _getEndOfDivRoundDown(uint256 x, uint256 y, uint256 denominator, uint256 prod0, uint256 prod1)\n        private\n        pure\n        returns (uint256 result)\n    {\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            unchecked {\n                result = prod0 / denominator;\n            }\n        } else {\n            // Make sure the result is less than 2^256. Also prevents denominator == 0\n            if (prod1 >= denominator) revert Uint256x256Math__MulDivOverflow();\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1\n            // See https://cs.stackexchange.com/q/138556/92363\n            unchecked {\n                // Does not overflow because the denominator cannot be zero at this stage in the function\n                uint256 lpotdod = denominator & (~denominator + 1);\n                assembly {\n                    // Divide denominator by lpotdod.\n                    denominator := div(denominator, lpotdod)\n\n                    // Divide [prod1 prod0] by lpotdod.\n                    prod0 := div(prod0, lpotdod)\n\n                    // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one\n                    lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n                }\n\n                // Shift in bits from prod1 into prod0\n                prod0 |= prod1 * lpotdod;\n\n                // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n                // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n                // four bits. That is, denominator * inv = 1 mod 2^4\n                uint256 inverse = (3 * denominator) ^ 2;\n\n                // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n                // in modular arithmetic, doubling the correct bits in each step\n                inverse *= 2 - denominator * inverse; // inverse mod 2^8\n                inverse *= 2 - denominator * inverse; // inverse mod 2^16\n                inverse *= 2 - denominator * inverse; // inverse mod 2^32\n                inverse *= 2 - denominator * inverse; // inverse mod 2^64\n                inverse *= 2 - denominator * inverse; // inverse mod 2^128\n                inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n                // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n                // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n                // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n                // is no longer required.\n                result = prod0 * inverse;\n            }\n        }\n    }\n}\n"
    },
    "contracts/mock/LBPair.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity =0.8.24;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title Liquidity Book Token Interface\n * @author Trader Joe\n * @notice Interface to interact with the LBToken.\n */\ninterface ILBToken {\n    error LBToken__AddressThisOrZero();\n    error LBToken__InvalidLength();\n    error LBToken__SelfApproval(address owner);\n    error LBToken__SpenderNotApproved(address from, address spender);\n    error LBToken__TransferExceedsBalance(address from, uint256 id, uint256 amount);\n    error LBToken__BurnExceedsBalance(address from, uint256 id, uint256 amount);\n\n    event TransferBatch(\n        address indexed sender, address indexed from, address indexed to, uint256[] ids, uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed account, address indexed sender, bool approved);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply(uint256 id) external view returns (uint256);\n\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    function isApprovedForAll(address owner, address spender) external view returns (bool);\n\n    function approveForAll(address spender, bool approved) external;\n\n    function batchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts) external;\n}\n\n/**\n * @title Liquidity Book Token\n * @author Trader Joe\n * @notice The LBToken is an implementation of a multi-token.\n * It allows to create multi-ERC20 represented by their ids.\n * Its implementation is really similar to the ERC1155 standard the main difference\n * is that it doesn't do any call to the receiver contract to prevent reentrancy.\n * As it's only for ERC20s, the uri function is not implemented.\n * The contract is made for batch operations.\n */\nabstract contract LBToken is ILBToken {\n    /**\n     * @dev The mapping from account to token id to account balance.\n     */\n    mapping(address => mapping(uint256 => uint256)) private _balances;\n\n    /**\n     * @dev The mapping from token id to total supply.\n     */\n    mapping(uint256 => uint256) private _totalSupplies;\n\n    /**\n     * @dev Mapping from account to spender approvals.\n     */\n    mapping(address => mapping(address => bool)) private _spenderApprovals;\n\n    /**\n     * @dev Modifier to check if the spender is approved for all.\n     */\n    modifier checkApproval(address from, address spender) {\n        if (!_isApprovedForAll(from, spender)) {\n            revert LBToken__SpenderNotApproved(from, spender);\n        }\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if the address is not zero or the contract itself.\n     */\n    modifier notAddressZeroOrThis(address account) {\n        if (account == address(0) || account == address(this)) {\n            revert LBToken__AddressThisOrZero();\n        }\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if the length of the arrays are equal.\n     */\n    modifier checkLength(uint256 lengthA, uint256 lengthB) {\n        if (lengthA != lengthB) revert LBToken__InvalidLength();\n        _;\n    }\n\n    /**\n     * @notice Returns the name of the token.\n     * @return The name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return \"Liquidity Book Token\";\n    }\n\n    /**\n     * @notice Returns the symbol of the token, usually a shorter version of the name.\n     * @return The symbol of the token.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return \"LBT\";\n    }\n\n    /**\n     * @notice Returns the total supply of token of type `id`.\n     * /**\n     * @dev This is the amount of token of type `id` minted minus the amount burned.\n     * @param id The token id.\n     * @return The total supply of that token id.\n     */\n    function totalSupply(uint256 id) public view virtual override returns (uint256) {\n        return _totalSupplies[id];\n    }\n\n    /**\n     * @notice Returns the amount of tokens of type `id` owned by `account`.\n     * @param account The address of the owner.\n     * @param id The token id.\n     * @return The amount of tokens of type `id` owned by `account`.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        return _balances[account][id];\n    }\n\n    /**\n     * @notice Return the balance of multiple (account/id) pairs.\n     * @param accounts The addresses of the owners.\n     * @param ids The token ids.\n     * @return batchBalances The balance for each (account, id) pair.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        public\n        view\n        virtual\n        override\n        checkLength(accounts.length, ids.length)\n        returns (uint256[] memory batchBalances)\n    {\n        batchBalances = new uint256[](accounts.length);\n\n        unchecked {\n            for (uint256 i; i < accounts.length; ++i) {\n                batchBalances[i] = balanceOf(accounts[i], ids[i]);\n            }\n        }\n    }\n\n    /**\n     * @notice Returns true if `spender` is approved to transfer `owner`'s tokens or if `spender` is the `owner`.\n     * @param owner The address of the owner.\n     * @param spender The address of the spender.\n     * @return True if `spender` is approved to transfer `owner`'s tokens.\n     */\n    function isApprovedForAll(address owner, address spender) public view virtual override returns (bool) {\n        return _isApprovedForAll(owner, spender);\n    }\n\n    /**\n     * @notice Grants or revokes permission to `spender` to transfer the caller's lbTokens, according to `approved`.\n     * @param spender The address of the spender.\n     * @param approved The boolean value to grant or revoke permission.\n     */\n    function approveForAll(address spender, bool approved) public virtual override {\n        _approveForAll(msg.sender, spender, approved);\n    }\n\n    /**\n     * @notice Batch transfers `amounts` of `ids` from `from` to `to`.\n     * @param from The address of the owner.\n     * @param to The address of the recipient.\n     * @param ids The list of token ids.\n     * @param amounts The list of amounts to transfer for each token id in `ids`.\n     */\n    function batchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts)\n        public\n        virtual\n        override\n        checkApproval(from, msg.sender)\n    {\n        _batchTransferFrom(from, to, ids, amounts);\n    }\n\n    /**\n     * @notice Returns true if `spender` is approved to transfer `owner`'s tokens or if `spender` is the `owner`.\n     * @param owner The address of the owner.\n     * @param spender The address of the spender.\n     * @return True if `spender` is approved to transfer `owner`'s tokens.\n     */\n    function _isApprovedForAll(address owner, address spender) internal view returns (bool) {\n        return owner == spender || _spenderApprovals[owner][spender];\n    }\n\n    /**\n     * @dev Mint `amount` of `id` to `account`.\n     * The `account` must not be the zero address.\n     * The event should be emitted by the contract that inherits this contract.\n     * @param account The address of the owner.\n     * @param id The token id.\n     * @param amount The amount to mint.\n     */\n    function _mint(address account, uint256 id, uint256 amount) internal {\n        _totalSupplies[id] += amount;\n\n        unchecked {\n            _balances[account][id] += amount;\n        }\n    }\n\n    /**\n     * @dev Burn `amount` of `id` from `account`.\n     * The `account` must not be the zero address.\n     * The event should be emitted by the contract that inherits this contract.\n     * @param account The address of the owner.\n     * @param id The token id.\n     * @param amount The amount to burn.\n     */\n    function _burn(address account, uint256 id, uint256 amount) internal {\n        mapping(uint256 => uint256) storage accountBalances = _balances[account];\n\n        uint256 balance = accountBalances[id];\n        if (balance < amount) {\n            revert LBToken__BurnExceedsBalance(account, id, amount);\n        }\n\n        unchecked {\n            _totalSupplies[id] -= amount;\n            accountBalances[id] = balance - amount;\n        }\n    }\n\n    /**\n     * @dev Batch transfers `amounts` of `ids` from `from` to `to`.\n     * The `to` must not be the zero address and the `ids` and `amounts` must have the same length.\n     * @param from The address of the owner.\n     * @param to The address of the recipient.\n     * @param ids The list of token ids.\n     * @param amounts The list of amounts to transfer for each token id in `ids`.\n     */\n    function _batchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts)\n        internal\n        checkLength(ids.length, amounts.length)\n        notAddressZeroOrThis(to)\n    {\n        mapping(uint256 => uint256) storage fromBalances = _balances[from];\n        mapping(uint256 => uint256) storage toBalances = _balances[to];\n\n        for (uint256 i; i < ids.length;) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = fromBalances[id];\n            if (fromBalance < amount) {\n                revert LBToken__TransferExceedsBalance(from, id, amount);\n            }\n\n            unchecked {\n                fromBalances[id] = fromBalance - amount;\n                toBalances[id] += amount;\n\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n    }\n\n    /**\n     * @notice Grants or revokes permission to `spender` to transfer the caller's tokens, according to `approved`\n     * @param owner The address of the owner\n     * @param spender The address of the spender\n     * @param approved The boolean value to grant or revoke permission\n     */\n    function _approveForAll(address owner, address spender, bool approved) internal notAddressZeroOrThis(owner) {\n        if (owner == spender) revert LBToken__SelfApproval(owner);\n\n        _spenderApprovals[owner][spender] = approved;\n        emit ApprovalForAll(owner, spender, approved);\n    }\n}\n\ncontract LBPair is LBToken, Ownable {\n    struct Bin {\n        uint128 binReserceX;\n        uint128 binReserceY;\n    }\n\n    uint128 reserveX;\n    uint128 reserveY;\n\n    mapping(uint256 => Bin) idBin;\n\n    constructor() Ownable(msg.sender) {}\n\n    function setBin(uint256 id, uint256 x, uint256 y) external onlyOwner {\n        idBin[id].binReserceX = uint128(x);\n        idBin[id].binReserceY = uint128(y);\n    }\n\n    function setReserves(uint256 x, uint256 y) external onlyOwner {\n        reserveX = uint128(x);\n        reserveY = uint128(y);\n    }\n\n    function getBin(uint24 id) external view returns (uint128, uint128) {\n        return (idBin[id].binReserceX, idBin[id].binReserceY);\n    }\n\n    function getReserves() external view returns (uint128, uint128) {\n        return (reserveX, reserveY);\n    }\n\n    function mint(address user, uint256 id, uint256 amount) external onlyOwner {\n        _mint(user, id, amount);\n    }\n\n    function burn(address user, uint256 id, uint256 amount) external onlyOwner {\n        _burn(user, id, amount);\n    }\n}\n"
    },
    "contracts/mock/LibTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.24;\n\nimport \"../libraries/BinHelper.sol\";\nimport \"../libraries/PackedUint128Math.sol\";\n\ncontract LibTest {\n    function encodeTest(uint128 x1, uint128 x2) external pure returns (bytes32) {\n        return PackedUint128Math.encode(x1, x2);\n    }\n\n    function decodeTest(bytes32 x) external pure returns (uint128, uint128) {\n        return PackedUint128Math.decode(x);\n    }\n\n    function getAmount(bytes32 binReserves, uint256 amountToBurn, uint256 totalSupply)\n        external\n        pure\n        returns (bytes32)\n    {\n        return BinHelper.getAmountOutOfBin(binReserves, amountToBurn, totalSupply);\n    }\n}\n"
    },
    "contracts/mock/LpToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract LpToken is ERC721, Ownable {\n    constructor() ERC721(\"MyToken\", \"MTK\") Ownable(msg.sender) {}\n\n    function safeMint(address to, uint256 tokenId) public onlyOwner {\n        _safeMint(to, tokenId);\n    }\n}\n"
    },
    "contracts/mock/NonfungiblePositionManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract NonfungiblePositionManager is ERC721, ERC721Burnable, Ownable {\n    constructor() ERC721(\"MyToken\", \"MTK\") Ownable(msg.sender) {}\n\n    function safeMint(address to, uint256 tokenId) public onlyOwner {\n        _safeMint(to, tokenId);\n    }\n\n    function positions(uint256 tokenId)\n        external\n        view\n        returns (\n            uint96 nonce,\n            address operator,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        )\n    {\n        liquidity = 54e18;\n    }\n}\n"
    },
    "contracts/mock/Token.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockToken is ERC20 {\n    constructor() ERC20(\"Mock syUSD\", \"syUSD\") {}\n\n    function mint(address to, uint256 amount) external {\n        _mint(to, amount);\n    }\n}\n"
    },
    "contracts/NFT-Staking/NftStaking.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.24;\n\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/ISynthrNFT.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract NftStaking is IERC721Receiver, Ownable2Step {\n    using SafeERC20 for IERC20;\n\n    /// @notice Address of reward token contract.\n    IERC20 public immutable REWARD_TOKEN;\n\n    uint256 public constant ACC_REWARD_PRECISION = 1e18;\n\n    /// @notice Info of each gauge controller user.\n    /// `amount` LP token amount the user has provided.\n    /// `rewardDebt` The amount of reward token entitled to the user.\n    struct UserInfo {\n        uint256 amount;\n        int256 rewardDebt;\n    }\n\n    /// @notice Info of each gauge pool.\n    struct NFTPoolInfo {\n        bool exist;\n        uint64 lastRewardBlock;\n        uint256 accRewardPerShare;\n        uint256 rewardPerBlock;\n        uint256 currentEpoch;\n        uint256 epoch;\n    }\n\n    /// @notice Total lock amount of users in VotingEscrow\n    uint256 public totalLockAmount;\n\n    /// @notice Info of each pool.\n    mapping(address => NFTPoolInfo) public poolInfo;\n\n    /// @notice Info of each user that stakes LP tokens.\n    mapping(address => mapping(address => UserInfo)) public userInfo;\n\n    /// @notice token id of user has deposited in pool.\n    mapping(address => mapping(uint256 => address)) public tokenOwner;\n\n    event Deposit(address indexed pool, address indexed user, uint256 tokenId);\n    event Withdraw(address indexed pool, address indexed user, uint256 tokenId);\n    event Claimed(address indexed pool, address indexed user, uint256 pendingRewardAmount);\n    event WithdrawAndClaim(address indexed pool, address indexed user, uint256 pendingRewardAmount);\n    event LogPoolAddition(address indexed owner, address[] pool);\n    event LogUpdatePool(address indexed pool, uint64 lastRewardBlock, uint256 accRewardPerShare);\n    event EpochUpdated(address indexed owner, address[] pool, uint256[] rewardPerBlock);\n    event totalLockAmountUpdated(address owner, uint256 totalLockAmount);\n\n    constructor(address _admin, address _rewardToken) Ownable(_admin) {\n        REWARD_TOKEN = IERC20(_rewardToken);\n    }\n\n    /// @dev retuen user reward debt\n    /// @param _pool address of pool\n    /// @param _user address of user\n    function userRewardsDebt(address _pool, address _user) external view returns (int256) {\n        return userInfo[_pool][_user].rewardDebt;\n    }\n\n    /// @notice View function to see pending reward of user in pool at current block.\n    /// @param _pool The address of the pool. See `poolInfo`.\n    /// @param _user Address of user.\n    /// @return pending_ reward for a given user.\n    function pendingReward(address _pool, address _user) external view returns (uint256 pending_) {\n        pending_ = _pendingRewardAmount(_pool, _user, block.number);\n    }\n\n    /// @notice View function to see pending reward of user in pool at future block.\n    /// @param _pool The address of the pool. See `poolInfo`.\n    /// @param _user Address of user.\n    /// @return pending_ reward for a given user.\n    function pendingRewardAtBlock(address _pool, address _user, uint256 _blockNumber)\n        external\n        view\n        returns (uint256 pending_)\n    {\n        pending_ = _pendingRewardAmount(_pool, _user, _blockNumber);\n    }\n\n    /// @notice set total locked token for lpSupply\n    function setTotalLockAmount(uint256 _totalLockAmount) external onlyOwner {\n        totalLockAmount = _totalLockAmount;\n\n        emit totalLockAmountUpdated(msg.sender, totalLockAmount);\n    }\n\n    function onERC721Received(address, address, uint256, bytes calldata) external override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /// @notice Add a new NFT pool. Can only be called by the owner.\n    function addPool(address[] memory _pool) external onlyOwner {\n        for (uint256 i; i < _pool.length; i++) {\n            poolInfo[_pool[i]].exist = true;\n            poolInfo[_pool[i]].lastRewardBlock = uint64(block.number);\n        }\n\n        emit LogPoolAddition(msg.sender, _pool);\n    }\n\n    /// @notice update epoch of pool\n    /// @param _pool addresses of pool to be updated.\n    /// @param _rewardPerBlock array of rewardPerBlock\n    function updateEpoch(address _user, uint256 _rewardAmount, address[] memory _pool, uint256[] memory _rewardPerBlock)\n        external\n        onlyOwner\n    {\n        require(_rewardPerBlock.length == _pool.length, \"NftStaking: length of array doesn't mach\");\n\n        for (uint256 i; i < _pool.length; i++) {\n            NFTPoolInfo memory _poolInfo = poolInfo[_pool[i]];\n            require(_poolInfo.exist, \"NftStaking: pool not exist\");\n            _poolInfo.rewardPerBlock = _rewardPerBlock[i];\n            _poolInfo.lastRewardBlock = uint64(block.number);\n            ++_poolInfo.epoch;\n            poolInfo[_pool[i]] = _poolInfo;\n        }\n\n        REWARD_TOKEN.safeTransferFrom(_user, address(this), _rewardAmount);\n\n        emit EpochUpdated(msg.sender, _pool, _rewardPerBlock);\n    }\n\n    /// @notice Update reward variables of the given pool.\n    /// @param _pool The address of the pool. See `NFTPoolInfo`.\n    /// @return _poolInfo Returns the pool that was updated.\n    function updatePool(address _pool) public returns (NFTPoolInfo memory _poolInfo) {\n        _poolInfo = poolInfo[_pool];\n        require(_poolInfo.exist, \"NftStaking: pool not exist\");\n        uint256 _lpSupply = totalLockAmount;\n        if (block.number > _poolInfo.lastRewardBlock) {\n            if (_lpSupply > 0) {\n                uint256 _blocks = block.number - _poolInfo.lastRewardBlock;\n                uint256 _rewardAmount = (_blocks * _poolInfo.rewardPerBlock);\n                _poolInfo.accRewardPerShare += _calAccPerShare(_rewardAmount, _lpSupply);\n            }\n            _poolInfo.lastRewardBlock = uint64(block.number);\n            poolInfo[_pool] = _poolInfo;\n            emit LogUpdatePool(_pool, _poolInfo.lastRewardBlock, _poolInfo.accRewardPerShare);\n        }\n    }\n\n    /// @notice Deposit NFT token.\n    /// @param _pool The address of the pool. See `NFTPoolInfo`.\n    function deposit(address _pool, uint256 _tokenId) external {\n        NFTPoolInfo memory _poolInfo = updatePool(_pool);\n\n        UserInfo memory _user = userInfo[_pool][msg.sender];\n        uint256 _lockAmount = ISynthrNFT(_pool).lockAmount(_tokenId);\n\n        // Effects\n        int256 _calRewardDebt = _calAccRewardPerShare(_poolInfo.accRewardPerShare, _lockAmount);\n\n        _user.amount += _lockAmount;\n        _user.rewardDebt += _calRewardDebt;\n\n        userInfo[_pool][msg.sender] = _user;\n        tokenOwner[_pool][_tokenId] = msg.sender;\n\n        ISynthrNFT(_pool).safeTransferFrom(msg.sender, address(this), _tokenId);\n\n        emit Deposit(_pool, msg.sender, _tokenId);\n    }\n\n    function withdraw(address _pool, uint256 _tokenId) external {\n        require(tokenOwner[_pool][_tokenId] == msg.sender, \"NftStaking: not access to tokenId\");\n        NFTPoolInfo memory _poolInfo = updatePool(_pool);\n        UserInfo memory _user = userInfo[_pool][msg.sender];\n\n        uint256 _lockAmount = ISynthrNFT(_pool).lockAmount(_tokenId);\n        int256 _calRewardDebt = _calAccRewardPerShare(_poolInfo.accRewardPerShare, _lockAmount);\n\n        _user.amount -= _lockAmount;\n        _user.rewardDebt -= _calRewardDebt;\n\n        userInfo[_pool][msg.sender] = _user;\n\n        // Interactions\n        ISynthrNFT(_pool).transferFrom(address(this), msg.sender, _tokenId);\n\n        delete tokenOwner[_pool][_tokenId];\n\n        emit Withdraw(_pool, msg.sender, _tokenId);\n    }\n\n    /// @notice Claim proceeds for transaction sender to `to`.\n    /// @param _pool The address of the pool. See `NFTPoolInfo`.\n    /// @param _to Receiver rewards.\n    function claim(address _pool, address _to) external {\n        NFTPoolInfo memory _poolInfo = updatePool(_pool);\n        UserInfo memory _user = userInfo[_pool][msg.sender];\n\n        int256 accumulatedReward = _calAccRewardPerShare(_poolInfo.accRewardPerShare, _user.amount);\n        uint256 _pendingReward = uint256(accumulatedReward - _user.rewardDebt);\n\n        // Effects\n        _user.rewardDebt = accumulatedReward;\n        userInfo[_pool][msg.sender] = _user;\n\n        // Interactions\n        if (_pendingReward != 0) {\n            REWARD_TOKEN.safeTransfer(_to, _pendingReward);\n        }\n\n        emit Claimed(msg.sender, _pool, _pendingReward);\n    }\n\n    /// @notice Withdraw NFT token from pool and claim proceeds for transaction sender to `to`.\n    /// @param _pool address of the pool. See `NFTPoolInfo`.\n    /// @param _to Receiver of the LP tokens and syUSD rewards.\n    function withdrawAndClaim(address _pool, uint256 _tokenId, address _to) external {\n        require(tokenOwner[_pool][_tokenId] == msg.sender, \"NftStaking: not access to tokenId\");\n        NFTPoolInfo memory _poolInfo = updatePool(_pool);\n        UserInfo memory _user = userInfo[_pool][msg.sender];\n\n        uint256 _lockAmount = ISynthrNFT(_pool).lockAmount(_tokenId);\n\n        int256 accumulatedReward = _calAccRewardPerShare(_poolInfo.accRewardPerShare, _user.amount);\n        uint256 _pendingReward = uint256(accumulatedReward - (_user.rewardDebt));\n\n        // Effects\n        _user.rewardDebt = accumulatedReward - (_calAccRewardPerShare(_poolInfo.accRewardPerShare, _lockAmount));\n        _user.amount -= _lockAmount;\n        userInfo[_pool][msg.sender] = _user;\n\n        // Interactions\n        if (_pendingReward != 0) {\n            REWARD_TOKEN.safeTransfer(_to, _pendingReward);\n        }\n\n        ISynthrNFT(_pool).transferFrom(address(this), msg.sender, _tokenId);\n\n        delete tokenOwner[_pool][_tokenId];\n\n        emit WithdrawAndClaim(_pool, msg.sender, _pendingReward);\n    }\n\n    function _pendingRewardAmount(address _pool, address _user, uint256 _blockNumber)\n        internal\n        view\n        returns (uint256 _pending)\n    {\n        uint256 _lpSupply = totalLockAmount;\n        NFTPoolInfo memory _poolInfo = poolInfo[_pool];\n        UserInfo memory _userInfo = userInfo[_pool][_user];\n        uint256 _accRewardPerShare = _poolInfo.accRewardPerShare;\n        if (_blockNumber > _poolInfo.lastRewardBlock && _lpSupply != 0) {\n            uint256 _blocks = _blockNumber - (_poolInfo.lastRewardBlock);\n            uint256 _rewardAmount = (_blocks * _poolInfo.rewardPerBlock);\n            _accRewardPerShare += (_calAccPerShare(_rewardAmount, _lpSupply));\n        }\n        _pending = uint256(_calAccRewardPerShare(_accRewardPerShare, _userInfo.amount) - _userInfo.rewardDebt);\n    }\n\n    function _calAccPerShare(uint256 _rewardAmount, uint256 _lpSupply) internal pure returns (uint256) {\n        return (_rewardAmount * ACC_REWARD_PRECISION) / _lpSupply;\n    }\n\n    function _calAccRewardPerShare(uint256 _accRewardPerShare, uint256 _amount) internal pure returns (int256) {\n        return int256((_amount * _accRewardPerShare) / ACC_REWARD_PRECISION);\n    }\n}\n"
    },
    "contracts/NFT-Staking/SynthrNFT.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.24;\n\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {Ownable2Step, Ownable} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\n/**\n * @title SynthrNFT\n * @dev A contract for creating and managing Synthr NFTs (Non-Fungible Tokens).\n */\ncontract SynthrNFT is ERC721, Ownable2Step {\n    uint256 public tokenIdCount;\n    mapping(uint256 tokenId => uint256 stakedAmount) public lockAmount;\n\n    event BatchMinted(address[] to, uint256 lastTokenIdMinted);\n\n    /**\n     * @dev Constructor to initialize the SynthrNFT contract.\n     * @param name_ The name of the NFT contract.\n     * @param symbol_ The symbol of the NFT contract.\n     * @param owner_ The initial owner of the contract.\n     */\n    constructor(string memory name_, string memory symbol_, address owner_) ERC721(name_, symbol_) Ownable(owner_) {}\n\n    /**\n     * @dev Safely mints a single token and assigns it to the specified address.\n     * @param to The address to which the token will be minted.\n     * @param lpAmount The amount of LP (Liquidity Provider (Synthr token)) tokens staked when obtaining this NFT.\n     * @return tokenId The ID of the minted token.\n     * @notice Only owner of this contract is allowed to mint tokens\n     */\n    function safeMint(address to, uint256 lpAmount) external onlyOwner returns (uint256 tokenId) {\n        tokenId = ++tokenIdCount;\n        _safeMint(to, tokenId);\n        lockAmount[tokenId] = lpAmount;\n    }\n\n    /**\n     * @dev Safely mints multiple tokens and assigns them to specified addresses.\n     * @param _to An array of addresses to which tokens will be minted.\n     * @param _lpAmount An array of LP amounts corresponding to each address.\n     * @notice Only owner of this contract is allowed to mint tokens\n     */\n    function safeMintBatch(address[] calldata _to, uint256[] calldata _lpAmount) external onlyOwner {\n        require(_to.length > 1, \"Synthr NFT: Mint more than one\");\n        uint256 tokenId = tokenIdCount;\n        for (uint256 i = 0; i < _to.length; i++) {\n            _safeMint(_to[i], ++tokenId);\n            lockAmount[tokenId] = _lpAmount[i];\n        }\n        tokenIdCount = tokenId;\n\n        emit BatchMinted(_to, tokenIdCount);\n    }\n}\n"
    },
    "contracts/Voter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.24;\n\nimport {IVoter} from \"./interfaces/IVoter.sol\";\nimport {IVotingEscrow} from \"./interfaces/IVotingEscrow.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ERC2771Context} from \"@openzeppelin/contracts/metatx/ERC2771Context.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {Time} from \"./libraries/Time.sol\";\n\n/// @title Voter\ncontract Voter is IVoter, ERC2771Context, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    uint256 internal constant MIN_MAXVOTINGNUM = 10;\n    address public ve;\n\n    address public governor;\n\n    address public emergencyCouncil;\n\n    uint256 public totalWeight;\n\n    uint256 public maxVotingNum;\n\n    // last added pool index\n    uint256 public index;\n\n    // pool => total weight\n    mapping(uint256 => uint256) public weights;\n\n    // user => pool => weight\n    mapping(address => mapping(uint256 => uint256)) public votes;\n\n    /// @dev address of user => List of pools voted for by user\n    mapping(address => uint256[]) public poolVote;\n\n    mapping(address => uint256) public usedWeights;\n\n    mapping(address => uint256) public lastVoted;\n\n    mapping(address => bool) public isWhitelistedUser;\n\n    mapping(uint256 => bool) public isAlive;\n\n    mapping(address => bool) public voted;\n\n    constructor(address _forwarder, address _ve) ERC2771Context(_forwarder) {\n        ve = _ve;\n\n        address _sender = _msgSender();\n        governor = _sender;\n\n        emergencyCouncil = _sender;\n        maxVotingNum = 30;\n    }\n\n    modifier onlyNewEpoch(address _user) {\n        // ensure new epoch since last vote\n        if (Time.epochStart(block.timestamp) <= lastVoted[_user]) {\n            revert AlreadyVotedOrDeposited();\n        }\n        if (block.timestamp <= Time.epochVoteStart(block.timestamp)) {\n            revert DistributeWindow();\n        }\n        _;\n    }\n\n    function epochStart(uint256 _timestamp) external pure returns (uint256) {\n        return Time.epochStart(_timestamp);\n    }\n\n    function epochNext(uint256 _timestamp) external pure returns (uint256) {\n        return Time.epochNext(_timestamp);\n    }\n\n    function epochVoteStart(uint256 _timestamp) external pure returns (uint256) {\n        return Time.epochVoteStart(_timestamp);\n    }\n\n    function epochVoteEnd(uint256 _timestamp) external pure returns (uint256) {\n        return Time.epochVoteEnd(_timestamp);\n    }\n\n    function setVe(address _ve) external {\n        if (_msgSender() != governor) revert NotGovernor();\n        ve = _ve;\n        emit VotingEscrowChanged(_ve);\n    }\n\n    function setGovernor(address _governor) external {\n        if (_msgSender() != governor) revert NotGovernor();\n        if (_governor == address(0)) revert ZeroAddress();\n        governor = _governor;\n    }\n\n    function setEmergencyCouncil(address _council) external {\n        if (_msgSender() != emergencyCouncil) revert NotEmergencyCouncil();\n        if (_council == address(0)) revert ZeroAddress();\n        emergencyCouncil = _council;\n    }\n\n    function setMaxVotingNum(uint256 _maxVotingNum) external {\n        if (_msgSender() != governor) revert NotGovernor();\n        if (_maxVotingNum < MIN_MAXVOTINGNUM) {\n            revert MaximumVotingNumberTooLow();\n        }\n        if (_maxVotingNum == maxVotingNum) revert SameValue();\n        maxVotingNum = _maxVotingNum;\n    }\n\n    function reset() external onlyNewEpoch(msg.sender) nonReentrant {\n        _reset(msg.sender);\n    }\n\n    function vote(uint256[] calldata _poolVote, uint256[] calldata _weights)\n        external\n        onlyNewEpoch(msg.sender)\n        nonReentrant\n    {\n        address _sender = _msgSender();\n        uint256 _weight = IVotingEscrow(ve).balanceOf(_sender, block.timestamp);\n        require(_weight != 0, \"Voter: no voting power\");\n\n        if (_poolVote.length != _weights.length) revert UnequalLengths();\n        if (_poolVote.length > maxVotingNum) revert TooManyPools();\n\n        uint256 _timestamp = block.timestamp;\n        if ((_timestamp > Time.epochVoteEnd(_timestamp)) && !isWhitelistedUser[msg.sender]) revert NotWhitelistedUser();\n        lastVoted[msg.sender] = _timestamp;\n\n        _vote(_sender, _weight, _poolVote, _weights);\n    }\n\n    function whitelistUser(address[] memory _user, bool[] memory _bool) external {\n        address _sender = _msgSender();\n        if (_sender != governor) {\n            revert NotGovernor();\n        }\n\n        if (_user.length != _bool.length) revert UnequalLengths();\n\n        for (uint256 i; i < _user.length; ++i) {\n            isWhitelistedUser[_user[i]] = _bool[i];\n        }\n        emit WhitelistUser(_sender, _user, _bool);\n    }\n\n    function addPool(uint256 _poolCount) external nonReentrant {\n        address sender = _msgSender();\n        if (sender != governor) revert NotGovernor();\n\n        uint256 _index = index + 1;\n        for (uint256 i; i < _poolCount; ++i) {\n            isAlive[_index + i] = true;\n        }\n\n        index = _index + _poolCount - 1;\n\n        emit PoolSet(_index + _poolCount - 1, sender);\n    }\n\n    function killPool(uint256 _pool) external {\n        if (_msgSender() != emergencyCouncil) revert NotEmergencyCouncil();\n        if (!isAlive[_pool]) revert PoolAlreadyKilled();\n\n        isAlive[_pool] = false;\n        emit PoolKilled(_pool);\n    }\n\n    function revivePool(uint256 _pool) external {\n        if (_msgSender() != emergencyCouncil) revert NotEmergencyCouncil();\n        if (isAlive[_pool]) revert PoolAlreadyRevived();\n        isAlive[_pool] = true;\n        emit PoolRevived(_pool);\n    }\n\n    function poke() external nonReentrant {\n        if (block.timestamp <= Time.epochVoteStart(block.timestamp)) {\n            revert DistributeWindow();\n        }\n        uint256 _weight = IVotingEscrow(ve).balanceOf(msg.sender, block.timestamp);\n        _poke(msg.sender, _weight);\n    }\n\n    function _poke(address _user, uint256 _weight) internal {\n        uint256[] memory _poolVote = poolVote[_user];\n        uint256 _poolCnt = _poolVote.length;\n        uint256[] memory _weights = new uint256[](_poolCnt);\n\n        for (uint256 i = 0; i < _poolCnt; i++) {\n            _weights[i] = votes[_user][_poolVote[i]];\n        }\n        _vote(_user, _weight, _poolVote, _weights);\n    }\n\n    function _reset(address _user) internal {\n        uint256[] storage _poolVote = poolVote[_user];\n        uint256 _poolVoteCnt = _poolVote.length;\n        uint256 _totalWeight = 0;\n\n        for (uint256 i = 0; i < _poolVoteCnt; i++) {\n            uint256 _pool = _poolVote[i];\n            uint256 _votes = votes[_user][_pool];\n\n            if (_votes != 0) {\n                weights[_pool] -= _votes;\n                delete votes[_user][_pool];\n\n                _totalWeight += _votes;\n                emit Abstained(_msgSender(), _pool, _user, _votes, weights[_pool], block.timestamp);\n            }\n        }\n        voted[_user] = false;\n\n        totalWeight -= _totalWeight;\n        usedWeights[_user] = 0;\n        delete poolVote[_user];\n    }\n\n    function _vote(address _user, uint256 _weight, uint256[] memory _poolVote, uint256[] memory _weights) internal {\n        _reset(_user);\n\n        uint256 _poolCnt = _poolVote.length;\n        uint256 _totalVoteWeight = 0;\n        uint256 _totalWeight = 0;\n        uint256 _usedWeight = 0;\n\n        for (uint256 i = 0; i < _poolCnt; i++) {\n            _totalVoteWeight += _weights[i];\n        }\n\n        for (uint256 i = 0; i < _poolCnt; i++) {\n            uint256 _pool = _poolVote[i];\n            if (!isAlive[_pool]) revert PoolNotAlive(_pool);\n\n            uint256 _poolWeight = (_weights[i] * _weight) / _totalVoteWeight;\n            if (votes[_user][_pool] != 0) revert NonZeroVotes();\n            if (_poolWeight == 0) revert ZeroBalance();\n\n            poolVote[_user].push(_pool);\n\n            weights[_pool] += _poolWeight;\n            votes[_user][_pool] += _poolWeight;\n\n            _usedWeight += _poolWeight;\n            _totalWeight += _poolWeight;\n\n            emit Voted(_msgSender(), _pool, _user, _poolWeight, weights[_pool], block.timestamp);\n        }\n        if (_usedWeight > 0) voted[_user] = true;\n        totalWeight += _totalWeight;\n        usedWeights[_user] = _usedWeight;\n    }\n}\n"
    },
    "contracts/VotingEscrow.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\nimport \"./interfaces/ISmartWalletChecker.sol\";\nimport \"./interfaces/IGaugeController.sol\";\n\ncontract VotingEscrow is AccessControl, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant DEPOSIT_FOR_TYPE = 0;\n    uint256 public constant CREATE_LOCK_TYPE = 1;\n    uint256 public constant INCREASE_LOCK_AMOUNT = 2;\n    uint256 public constant INCREASE_UNLOCK_TIME = 3;\n    uint256 public constant INCREASE_UNLOCK_TIME_AND_LOCK_AMOUNT = 4;\n\n    uint256 public constant WEEK = 7 * 86400; // all future times are rounded by week\n    uint256 public constant MAXTIME = 4 * 365 * 86400; // 4 years\n    uint256 public constant MULTIPLIER = 10 ** 18;\n\n    bytes32 public constant CONTROLLER_ROLE = keccak256(\"CONTROLLER_ROLE\");\n\n    struct Point {\n        int256 bias;\n        int256 slope;\n        uint256 timeStamp;\n        uint256 blockNumber;\n    }\n\n    struct LockedBalance {\n        int256 amount;\n        uint256 end;\n    }\n\n    string public name;\n    string public symbol;\n    string public version;\n\n    uint256 public decimals;\n    uint256 public supply;\n    uint256 public epoch;\n\n    address public futureSmartWalletChecker;\n    address public smartWalletChecker;\n\n    address public admin;\n    address public futureAdmin;\n\n    address public token;\n    address public controller;\n    address public gaugeController;\n\n    bool public transfersEnabled;\n\n    Point[100000000000000000000000000000] public pointHistory;\n\n    mapping(address => LockedBalance) public locked;\n    mapping(address => Point[1000000000]) public userPointHistory;\n    mapping(address => uint256) public userPointEpoch;\n    mapping(uint256 => uint256) public slopeChanges;\n\n    event OwnershipCommited(address admin);\n    event OwnershipApplied(address admin);\n    event WalletCommited(address newSmartWalletChecker);\n    event ControllerChanged(address indexed prevController, address indexed newController);\n    event Deposited(address indexed provider, uint256 value, uint256 indexed locktime, uint256 _type, uint256 ts);\n    event Withdrew(address indexed provider, uint256 value, uint256 timeStamp);\n    event Supply(uint256 prevSupply, uint256 supply);\n    event GaugeUpdated(address indexed newGauge);\n\n    constructor(\n        address _tokenAddr,\n        address _gaugeController,\n        string memory _name,\n        string memory _symbol,\n        string memory _version\n    ) {\n        admin = msg.sender;\n        token = _tokenAddr;\n        gaugeController = _gaugeController;\n        pointHistory[0].blockNumber = block.number;\n        pointHistory[0].timeStamp = block.timestamp;\n        controller = msg.sender;\n        transfersEnabled = true;\n\n        uint256 _decimals = ERC20(_tokenAddr).decimals();\n        require(_decimals <= 255);\n        decimals = _decimals;\n\n        name = _name;\n        symbol = _symbol;\n        version = _version;\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(CONTROLLER_ROLE, msg.sender);\n    }\n\n    function getLastUserSlope(address _user) external view returns (int256) {\n        uint256 uepoch = userPointEpoch[_user];\n        return userPointHistory[_user][uepoch].slope;\n    }\n\n    function userPointHistoryTs(address _user, uint256 _idx) external view returns (uint256) {\n        return userPointHistory[_user][_idx].timeStamp;\n    }\n\n    function lockedEnd(address _user) external view returns (uint256) {\n        return locked[_user].end;\n    }\n\n    function balanceOf(address _user, uint256 _t) external view returns (uint256) {\n        uint256 _epoch = userPointEpoch[_user];\n        if (_epoch == 0) {\n            return 0;\n        } else {\n            Point memory lastPoint = userPointHistory[_user][_epoch];\n            lastPoint.bias -= lastPoint.slope * int256(_t - lastPoint.timeStamp);\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n            return uint256(int256(lastPoint.bias));\n        }\n    }\n\n    function balanceOfAt(address _user, uint256 _block) external view returns (uint256) {\n        require(_block <= block.number, \"VotingEscrow: Wrong condition\");\n        uint256 _min;\n        uint256 _max = userPointEpoch[_user];\n        for (uint256 i; i < 128; ++i) {\n            if (_min >= _max) {\n                break;\n            }\n            uint256 _mid = (_min + _max + 1) / 2;\n            if (userPointHistory[_user][_mid].blockNumber <= _block) {\n                _min = _mid;\n            } else {\n                _max = _mid - 1;\n            }\n        }\n        Point memory upoint = userPointHistory[_user][_min];\n        uint256 maxEpoch = epoch;\n        uint256 _epoch = _findBlockEpoch(_block, maxEpoch);\n        Point memory point0 = pointHistory[_epoch];\n        uint256 blockDifference;\n        uint256 timeStampDiffrence;\n        if (_epoch < maxEpoch) {\n            Point memory point1 = pointHistory[_epoch + 1];\n            blockDifference = point1.blockNumber - point0.blockNumber;\n            timeStampDiffrence = point1.timeStamp - point0.timeStamp;\n        } else {\n            blockDifference = block.number - point0.blockNumber;\n            timeStampDiffrence = block.timestamp - point0.timeStamp;\n        }\n\n        uint256 blockTime = point0.timeStamp;\n        if (blockDifference != 0) {\n            blockTime += (timeStampDiffrence * (_block - point0.blockNumber)) / blockDifference;\n        }\n        upoint.bias -= upoint.slope * int128(int256(blockTime - upoint.timeStamp));\n        if (upoint.bias >= 0) {\n            return uint256(int256(upoint.bias));\n        } else {\n            return 0;\n        }\n    }\n\n    function totalSupply(uint256 _t) external view returns (uint256) {\n        uint256 _epoch = epoch;\n        Point memory lastPoint = pointHistory[_epoch];\n        return _supplyAt(lastPoint, _t);\n    }\n\n    function totalSupplyAt(uint256 _block) external view returns (uint256) {\n        require(_block <= block.number, \"VotingEscrow: Invalid Block Number\");\n        uint256 _epoch = epoch;\n        uint256 targetEpoch = _findBlockEpoch(_block, _epoch);\n        Point memory point = pointHistory[targetEpoch];\n        uint256 timeStampDiffrence;\n        if (targetEpoch < _epoch) {\n            Point memory pointNext = pointHistory[targetEpoch + 1];\n            if (point.blockNumber != pointNext.blockNumber) {\n                timeStampDiffrence = ((_block - point.blockNumber) * (pointNext.timeStamp - point.timeStamp))\n                    / (pointNext.blockNumber - point.blockNumber);\n            }\n        } else {\n            if (point.blockNumber != block.number) {\n                timeStampDiffrence = timeStampDiffrence = (\n                    (_block - point.blockNumber) * (block.timestamp - point.timeStamp)\n                ) / (block.number - point.blockNumber);\n            }\n        }\n        return _supplyAt(point, point.timeStamp + timeStampDiffrence);\n    }\n\n    function changeController(address _newController) external {\n        require(hasRole(CONTROLLER_ROLE, msg.sender), \"VotingEscrow: Invalid Caller\");\n        _revokeRole(CONTROLLER_ROLE, msg.sender);\n        _grantRole(CONTROLLER_ROLE, _newController);\n        controller = _newController;\n\n        emit ControllerChanged(msg.sender, _newController);\n    }\n\n    function setGaugeController(address _newController) external {\n        gaugeController = _newController;\n        emit GaugeUpdated(_newController);\n    }\n\n    function checkpoint() external {\n        _checkpoint(address(0), LockedBalance(0, 0), LockedBalance(0, 0));\n    }\n\n    function commitTransferOwnership(address _user) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"VotingEscrow: admin only\");\n        futureAdmin = _user;\n        emit OwnershipCommited(_user);\n    }\n\n    function applyTransferOwnership() external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"VotingEscrow: admin only\");\n        address _admin = futureAdmin;\n        require(_admin != address(0), \"VotingEscrow: Admin not set\");\n        admin = _admin;\n        emit OwnershipApplied(_admin);\n    }\n\n    function commitSmartWalletChecker(address _user) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"VotingEscrow: admin only\");\n        futureSmartWalletChecker = _user;\n        emit WalletCommited(_user);\n    }\n\n    function applySmartWalletChecker() external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"VotingEscrow: admin only\");\n        smartWalletChecker = futureSmartWalletChecker;\n        emit WalletCommited(futureSmartWalletChecker);\n    }\n\n    function depositFor(address _user, uint256 _value) external nonReentrant {\n        LockedBalance memory _locked = locked[_user];\n\n        require(_value > 0, \"VotingEscrow: Need non-zero value\");\n        require(_locked.amount > 0, \"VotingEscrow: No existing lock found\");\n        require(_locked.end > block.timestamp, \"VotingEscrow: Cannot add to an expired lock. Withdraw\");\n\n        _depositFor(_user, _value, 0, locked[_user], DEPOSIT_FOR_TYPE);\n    }\n\n    function createLock(uint256 _value, uint256 _unlockTime) external nonReentrant {\n        _assertNotContract(msg.sender);\n        uint256 unlockTime = (_unlockTime / WEEK) * WEEK;\n        LockedBalance storage _locked = locked[msg.sender];\n\n        require(_value > 0, \"VotingEscrow: need non-zero value\");\n        require(_locked.amount == 0, \"VotingEscrow: Withdraw old tokens first\");\n        require(unlockTime > block.timestamp, \"VotingEscrow: Can only lock until a time in the future\");\n        require(unlockTime <= MAXTIME + block.timestamp, \"VotingEscrow: Voting lock can be 4 years max\");\n        _depositFor(msg.sender, _value, unlockTime, _locked, CREATE_LOCK_TYPE);\n    }\n\n    function increaseAmount(uint256 _value) external nonReentrant {\n        _assertNotContract(msg.sender);\n        LockedBalance storage _locked = locked[msg.sender];\n\n        require(_value > 0, \"VotingEscrow: need non-zero value\");\n        require(_locked.amount > 0, \"VotingEscrow: No existing lock found\");\n        require(_locked.end > block.timestamp, \"VotingEscrow: Cannot add to an expired lock. Withdraw\");\n\n        _depositFor(msg.sender, _value, 0, _locked, INCREASE_LOCK_AMOUNT);\n    }\n\n    function increaseAmountAndUnlockTime(uint256 _value, uint256 _unlockTime) external nonReentrant {\n        _assertNotContract(msg.sender);\n        LockedBalance storage _locked = locked[msg.sender];\n        uint256 unlockTime = (_unlockTime / WEEK) * WEEK;\n\n        require(_value > 0, \"VotingEscrow: need non-zero value\");\n        require(_locked.amount > 0, \"VotingEscrow: No existing lock found\");\n        require(_locked.end > block.timestamp, \"VotingEscrow: Cannot add to an expired lock. Withdraw\");\n        require(unlockTime > _locked.end, \"VotingEscrow: Can only increase lock duration\");\n        require(unlockTime <= block.timestamp + MAXTIME, \"VotingEscrow: Voting lock can be 4 years max\");\n\n        _depositFor(msg.sender, _value, unlockTime, _locked, INCREASE_UNLOCK_TIME_AND_LOCK_AMOUNT);\n    }\n\n    function withdraw() external nonReentrant {\n        LockedBalance storage _locked = locked[msg.sender];\n        require(block.timestamp >= _locked.end, \"VotingEscrow: The lock didn't expire\");\n        uint256 _value = uint256(int256(_locked.amount));\n        LockedBalance storage oldLocked = _locked;\n        _locked.end = 0;\n        _locked.amount = 0;\n        supply -= _value;\n\n        _checkpoint(msg.sender, oldLocked, _locked);\n        IERC20(token).safeTransfer(msg.sender, _value);\n        IGaugeController(gaugeController).updateReward(address(this), msg.sender, _value, false);\n        emit Withdrew(msg.sender, _value, block.timestamp);\n        emit Supply(supply + _value, supply);\n    }\n\n    function increaseUnlockTime(uint256 _unlockTime) external nonReentrant {\n        _assertNotContract(msg.sender);\n        LockedBalance storage _locked = locked[msg.sender];\n        uint256 unlockTime = (_unlockTime / WEEK) * WEEK;\n        require(_locked.end > block.timestamp, \"VotingEscrow: Lock expired\");\n        require(_locked.amount > 0, \"VotingEscrow: Nothing is locked\");\n        require(unlockTime > _locked.end, \"VotingEscrow: Can only increase lock duration\");\n        require(unlockTime <= block.timestamp + MAXTIME, \"VotingEscrow: Voting lock can be 4 years max\");\n\n        _depositFor(msg.sender, 0, unlockTime, _locked, INCREASE_UNLOCK_TIME);\n    }\n\n    function _findBlockEpoch(uint256 _block, uint256 _maxEpoch) internal view returns (uint256) {\n        uint256 _min = 0;\n        uint256 _max = _maxEpoch;\n        for (uint256 i = 0; i < 128; i++) {\n            if (_min >= _max) {\n                break;\n            }\n            uint256 _mid = (_min + _max + 1) / 2;\n            if (pointHistory[_mid].blockNumber <= _block) {\n                _min = _mid;\n            } else {\n                _max = _mid - 1;\n            }\n        }\n        return _min;\n    }\n\n    function _supplyAt(Point memory _point, uint256 _time) internal view returns (uint256) {\n        Point memory lastPoint = _point;\n        uint256 timeInterval = (lastPoint.timeStamp / WEEK) * WEEK;\n        for (uint256 i; i < 255; ++i) {\n            timeInterval += WEEK;\n            int128 dSlope;\n            if (timeInterval > _time) {\n                timeInterval = _time;\n            } else {\n                dSlope = int128(int256(slopeChanges[timeInterval]));\n            }\n            lastPoint.bias -= lastPoint.slope * int256(timeInterval - lastPoint.timeStamp);\n            if (timeInterval == _time) {\n                break;\n            }\n            lastPoint.slope += dSlope;\n            lastPoint.timeStamp = timeInterval;\n        }\n        if (lastPoint.bias < 0) {\n            lastPoint.bias = 0;\n        }\n        return uint256(int256(lastPoint.bias));\n    }\n\n    function _assertNotContract(address _user) internal {\n        if (_user != tx.origin) {\n            address checker = smartWalletChecker;\n            if (checker != address(0)) {\n                if (ISmartWalletChecker(checker).check(_user)) {\n                    return;\n                }\n            }\n            revert(\"VotingEscrow: Smart contract depositors not allowed\");\n        }\n    }\n\n    function _checkpoint(address _user, LockedBalance memory _oldLocked, LockedBalance memory _newLocked) internal {\n        Point memory _uOld;\n        Point memory _uNew;\n        int256 _oldDslope = 0;\n        int256 _newDslope = 0;\n        uint256 _epoch = epoch;\n\n        if (_user != address(0)) {\n            // Calculate slopes and biases\n            // Kept at zero when they have to\n            if (_oldLocked.end > block.timestamp && _oldLocked.amount > 0) {\n                unchecked {\n                    _uOld.slope = _oldLocked.amount / int256(MAXTIME);\n                }\n                _uOld.bias = _uOld.slope * int256(_oldLocked.end - block.timestamp);\n            }\n            if (_newLocked.end > block.timestamp && _newLocked.amount > 0) {\n                unchecked {\n                    _uNew.slope = _newLocked.amount / int256(MAXTIME);\n                }\n                _uNew.bias = _uNew.slope * int256(_newLocked.end - block.timestamp);\n            }\n\n            // Read values of scheduled changes in the slope\n            // _oldLocked.end can be in the past and in the future\n            // _newLocked.end can ONLY by in the FUTURE unless everything expired than zeros\n            _oldDslope = int256(slopeChanges[_oldLocked.end]);\n            if (_newLocked.end != 0) {\n                if (_newLocked.end == _oldLocked.end) {\n                    _newDslope = _oldDslope;\n                } else {\n                    _newDslope = int256(slopeChanges[_newLocked.end]);\n                }\n            }\n        }\n        Point memory _lastPoint = Point({bias: 0, slope: 0, timeStamp: block.timestamp, blockNumber: block.number});\n        if (_epoch > 0) {\n            _lastPoint = pointHistory[_epoch];\n        }\n        uint256 _lastCheckpoint = _lastPoint.timeStamp;\n        // _initial_lastPoint is used for extrapolation to calculate block number\n        // (approximately, for *At methods) and save them\n        // as we cannot figure that out exactly from inside the contract\n        Point memory _initialLastPoint = _lastPoint;\n        uint256 _blockSlope = 0; // dblock/dt\n        if (block.timestamp > _lastPoint.timeStamp) {\n            _blockSlope =\n                (MULTIPLIER * (block.number - _lastPoint.blockNumber)) / (block.timestamp - _lastPoint.timeStamp);\n        }\n        // If last point is already recorded in this block, slope=0\n        // But that's ok b/c we know the block in such case\n\n        // Go over weeks to fill history and calculate what the current point is\n        uint256 _timeInterval;\n        unchecked {\n            _timeInterval = (_lastCheckpoint / WEEK) * WEEK;\n        }\n        for (uint256 i; i < 255;) {\n            // Hopefully it won't happen that this won't get used in 5 years!\n            // If it does, users will be able to withdraw but vote weight will be broken\n            _timeInterval += WEEK;\n            int256 d_slope = 0;\n            if (_timeInterval > block.timestamp) {\n                _timeInterval = block.timestamp;\n            } else {\n                d_slope = int256(slopeChanges[_timeInterval]);\n            }\n            _lastPoint.bias = _lastPoint.bias - _lastPoint.slope * int256(_timeInterval - _lastCheckpoint);\n            _lastPoint.slope += d_slope;\n            if (_lastPoint.bias < 0) {\n                // This can happen\n                _lastPoint.bias = 0;\n            }\n            if (_lastPoint.slope < 0) {\n                // This cannot happen - just in case\n                _lastPoint.slope = 0;\n            }\n            _lastCheckpoint = _timeInterval;\n            _lastPoint.timeStamp = _timeInterval;\n            _lastPoint.blockNumber = _initialLastPoint.blockNumber\n                + ((_blockSlope * (_timeInterval - _initialLastPoint.timeStamp)) / MULTIPLIER);\n            _epoch += 1;\n            if (_timeInterval == block.timestamp) {\n                _lastPoint.blockNumber = block.number;\n                break;\n            } else {\n                pointHistory[_epoch] = _lastPoint;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        epoch = _epoch;\n        // Now pointHistory is filled until t=now\n\n        if (_user != address(0)) {\n            // If last point was in this block, the slope change has been applied already\n            // But in such case we have 0 slope(s)\n            _lastPoint.slope += _uNew.slope - _uOld.slope;\n            _lastPoint.bias += _uNew.bias - _uOld.bias;\n            if (_lastPoint.slope < 0) {\n                _lastPoint.slope = 0;\n            }\n            if (_lastPoint.bias < 0) {\n                _lastPoint.bias = 0;\n            }\n        }\n        // Record the changed point into history\n        pointHistory[_epoch] = _lastPoint;\n\n        address _user2 = _user; //To avoid being \"Stack Too Deep\"\n\n        if (_user2 != address(0)) {\n            // Schedule the slope changes (slope is going down)\n            // We subtract new_user_slope from [_newLocked.end]\n            // and add old_user_slope to [_oldLocked.end]\n            if (_oldLocked.end > block.timestamp) {\n                // _oldDslope was <something> - _uOld.slope, so we cancel that\n                _oldDslope += _uOld.slope;\n                if (_newLocked.end == _oldLocked.end) {\n                    _oldDslope -= _uNew.slope; // It was a new deposit, not extension\n                }\n                slopeChanges[_oldLocked.end] = uint256(_oldDslope);\n            }\n            if (_newLocked.end > block.timestamp) {\n                if (_newLocked.end > _oldLocked.end) {\n                    _newDslope -= _uNew.slope; // old slope disappeared at this point\n                    slopeChanges[_newLocked.end] = uint256(_newDslope);\n                }\n                // else we recorded it already in _oldDslope\n            }\n\n            // Now handle user history\n            uint256 _user_epoch;\n            unchecked {\n                _user_epoch = userPointEpoch[_user2] + 1;\n            }\n\n            userPointEpoch[_user2] = _user_epoch;\n            _uNew.timeStamp = block.timestamp;\n            _uNew.blockNumber = block.number;\n            userPointHistory[_user2][_user_epoch] = _uNew;\n        }\n    }\n\n    function _depositFor(\n        address _user,\n        uint256 _value,\n        uint256 _unlockTime,\n        LockedBalance memory lockedBalance,\n        uint256 _type\n    ) internal {\n        LockedBalance memory _locked = lockedBalance;\n        uint256 supplyBefore = supply;\n        supply = supplyBefore + _value;\n        LockedBalance memory oldLocked = _locked;\n        _locked.amount += int128(uint128(_value));\n        if (_unlockTime != 0) {\n            _locked.end = _unlockTime;\n        }\n        locked[_user] = _locked;\n        _checkpoint(_user, oldLocked, _locked);\n        if (_value != 0) {\n            IERC20(token).safeTransferFrom(_user, address(this), _value);\n            IGaugeController(gaugeController).updateReward(address(this), _user, _value, true);\n        }\n        emit Deposited(_user, _value, _locked.end, _type, block.timestamp);\n        emit Supply(supplyBefore, supplyBefore + _value);\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
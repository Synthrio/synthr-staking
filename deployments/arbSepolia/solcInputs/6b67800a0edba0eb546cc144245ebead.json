{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/interfaces/IGaugeController.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.24;\n\ninterface IGaugeController {\n    function updateReward(address pool, address user, uint256 amount, bool increase) external;\n\n    function decreaseRewardAndClaim(address pool, uint256 amount, address user) external;\n}\n"
    },
    "contracts/interfaces/ISmartWalletChecker.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.24;\n\ninterface ISmartWalletChecker {\n    function check(address user) external returns (bool);\n}\n"
    },
    "contracts/interfaces/ISynthrNFT.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.24;\n\ninterface ISynthrNFT {\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function lockAmount(uint256 _tokenId) external view returns (uint256);\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function safeMint(address to, uint256 lpAmount) external returns (uint256);\n    function safeMintBatch(address[] calldata _to, uint256[] calldata _lpAmount) external;\n}\n"
    },
    "contracts/NFT-Staking/NftStaking.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.24;\n\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/ISynthrNFT.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\ncontract NftStaking is IERC721Receiver, Ownable2Step {\n    using SafeERC20 for IERC20;\n\n    /// @notice Address of reward token contract.\n    IERC20 public immutable REWARD_TOKEN;\n\n    uint256 public constant ACC_REWARD_PRECISION = 1e18;\n\n    /// @notice Info of each gauge controller user.\n    /// `amount` LP token amount the user has provided.\n    /// `rewardDebt` The amount of reward token entitled to the user.\n    struct UserInfo {\n        uint256 amount;\n        int256 rewardDebt;\n    }\n\n    /// @notice Info of each gauge pool.\n    struct NFTPoolInfo {\n        bool exist;\n        uint64 lastRewardBlock;\n        uint256 accRewardPerShare;\n        uint256 rewardPerBlock;\n        uint256 currentEpoch;\n        uint256 epoch;\n    }\n\n    /// @notice Total lock amount of users in VotingEscrow\n    uint256 public totalLockAmount;\n\n    /// @notice Info of each pool.\n    mapping(address => NFTPoolInfo) public poolInfo;\n\n    /// @notice Info of each user that stakes LP tokens.\n    mapping(address => mapping(address => UserInfo)) public userInfo;\n\n    /// @notice token id of user has deposited in pool.\n    mapping(address => mapping(uint256 => address)) public tokenOwner;\n\n    event Deposit(address indexed pool, address indexed user, uint256 tokenId);\n    event Withdraw(address indexed pool, address indexed user, uint256 tokenId);\n    event Claimed(address indexed pool, address indexed user, uint256 pendingRewardAmount);\n    event WithdrawAndClaim(address indexed pool, address indexed user, uint256 pendingRewardAmount);\n    event LogPoolAddition(address indexed owner, address[] pool);\n    event LogUpdatePool(address indexed pool, uint64 lastRewardBlock, uint256 accRewardPerShare);\n    event EpochUpdated(address indexed owner, address[] pool, uint256[] rewardPerBlock);\n    event totalLockAmountUpdated(address owner, uint256 totalLockAmount);\n\n    constructor(address _admin, address _rewardToken) Ownable(_admin) {\n        REWARD_TOKEN = IERC20(_rewardToken);\n    }\n\n    /// @dev retuen user reward debt\n    /// @param _pool address of pool\n    /// @param _user address of user\n    function userRewardsDebt(address _pool, address _user) external view returns (int256) {\n        return userInfo[_pool][_user].rewardDebt;\n    }\n\n    /// @notice View function to see pending reward of user in pool at current block.\n    /// @param _pool The address of the pool. See `poolInfo`.\n    /// @param _user Address of user.\n    /// @return pending_ reward for a given user.\n    function pendingReward(address _pool, address _user) external view returns (uint256 pending_) {\n        pending_ = _pendingRewardAmount(_pool, _user, block.number);\n    }\n\n    /// @notice View function to see pending reward of user in pool at future block.\n    /// @param _pool The address of the pool. See `poolInfo`.\n    /// @param _user Address of user.\n    /// @return pending_ reward for a given user.\n    function pendingRewardAtBlock(address _pool, address _user, uint256 _blockNumber)\n        external\n        view\n        returns (uint256 pending_)\n    {\n        pending_ = _pendingRewardAmount(_pool, _user, _blockNumber);\n    }\n\n    /// @notice set total locked token for lpSupply\n    function setTotalLockAmount(uint256 _totalLockAmount) external onlyOwner {\n        totalLockAmount = _totalLockAmount;\n\n        emit totalLockAmountUpdated(msg.sender, totalLockAmount);\n    }\n\n    function onERC721Received(address, address, uint256, bytes calldata) external override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /// @notice Add a new NFT pool. Can only be called by the owner.\n    function addPool(address[] memory _pool) external onlyOwner {\n        for (uint256 i; i < _pool.length; i++) {\n            poolInfo[_pool[i]].exist = true;\n            poolInfo[_pool[i]].lastRewardBlock = uint64(block.number);\n        }\n\n        emit LogPoolAddition(msg.sender, _pool);\n    }\n\n    /// @notice update epoch of pool\n    /// @param _pool addresses of pool to be updated.\n    /// @param _rewardPerBlock array of rewardPerBlock\n    function updateEpoch(address _user, uint256 _rewardAmount, address[] memory _pool, uint256[] memory _rewardPerBlock)\n        external\n        onlyOwner\n    {\n        require(_rewardPerBlock.length == _pool.length, \"NftStaking: length of array doesn't mach\");\n\n        for (uint256 i; i < _pool.length; i++) {\n            NFTPoolInfo memory _poolInfo = poolInfo[_pool[i]];\n            require(_poolInfo.exist, \"NftStaking: pool not exist\");\n            _poolInfo.rewardPerBlock = _rewardPerBlock[i];\n            _poolInfo.lastRewardBlock = uint64(block.number);\n            ++_poolInfo.epoch;\n            poolInfo[_pool[i]] = _poolInfo;\n        }\n\n        REWARD_TOKEN.safeTransferFrom(_user, address(this), _rewardAmount);\n\n        emit EpochUpdated(msg.sender, _pool, _rewardPerBlock);\n    }\n\n    /// @notice Update reward variables of the given pool.\n    /// @param _pool The address of the pool. See `NFTPoolInfo`.\n    /// @return _poolInfo Returns the pool that was updated.\n    function updatePool(address _pool) public returns (NFTPoolInfo memory _poolInfo) {\n        _poolInfo = poolInfo[_pool];\n        require(_poolInfo.exist, \"NftStaking: pool not exist\");\n        uint256 _lpSupply = totalLockAmount;\n        if (block.number > _poolInfo.lastRewardBlock) {\n            if (_lpSupply > 0) {\n                uint256 _blocks = block.number - _poolInfo.lastRewardBlock;\n                uint256 _rewardAmount = (_blocks * _poolInfo.rewardPerBlock);\n                _poolInfo.accRewardPerShare += _calAccPerShare(_rewardAmount, _lpSupply);\n            }\n            _poolInfo.lastRewardBlock = uint64(block.number);\n            poolInfo[_pool] = _poolInfo;\n            emit LogUpdatePool(_pool, _poolInfo.lastRewardBlock, _poolInfo.accRewardPerShare);\n        }\n    }\n\n    /// @notice Deposit NFT token.\n    /// @param _pool The address of the pool. See `NFTPoolInfo`.\n    function deposit(address _pool, uint256 _tokenId) external {\n        NFTPoolInfo memory _poolInfo = updatePool(_pool);\n\n        UserInfo memory _user = userInfo[_pool][msg.sender];\n        uint256 _lockAmount = ISynthrNFT(_pool).lockAmount(_tokenId);\n\n        // Effects\n        int256 _calRewardDebt = _calAccRewardPerShare(_poolInfo.accRewardPerShare, _lockAmount);\n\n        _user.amount += _lockAmount;\n        _user.rewardDebt += _calRewardDebt;\n\n        userInfo[_pool][msg.sender] = _user;\n        tokenOwner[_pool][_tokenId] = msg.sender;\n\n        ISynthrNFT(_pool).safeTransferFrom(msg.sender, address(this), _tokenId);\n\n        emit Deposit(_pool, msg.sender, _tokenId);\n    }\n\n    function withdraw(address _pool, uint256 _tokenId) external {\n        require(tokenOwner[_pool][_tokenId] == msg.sender, \"NftStaking: not access to tokenId\");\n        NFTPoolInfo memory _poolInfo = updatePool(_pool);\n        UserInfo memory _user = userInfo[_pool][msg.sender];\n\n        uint256 _lockAmount = ISynthrNFT(_pool).lockAmount(_tokenId);\n        int256 _calRewardDebt = _calAccRewardPerShare(_poolInfo.accRewardPerShare, _lockAmount);\n\n        _user.amount -= _lockAmount;\n        _user.rewardDebt -= _calRewardDebt;\n\n        userInfo[_pool][msg.sender] = _user;\n\n        // Interactions\n        ISynthrNFT(_pool).transferFrom(address(this), msg.sender, _tokenId);\n\n        delete tokenOwner[_pool][_tokenId];\n\n        emit Withdraw(_pool, msg.sender, _tokenId);\n    }\n\n    /// @notice Claim proceeds for transaction sender to `to`.\n    /// @param _pool The address of the pool. See `NFTPoolInfo`.\n    /// @param _to Receiver rewards.\n    function claim(address _pool, address _to) external {\n        NFTPoolInfo memory _poolInfo = updatePool(_pool);\n        UserInfo memory _user = userInfo[_pool][msg.sender];\n\n        int256 accumulatedReward = _calAccRewardPerShare(_poolInfo.accRewardPerShare, _user.amount);\n        uint256 _pendingReward = uint256(accumulatedReward - _user.rewardDebt);\n\n        // Effects\n        _user.rewardDebt = accumulatedReward;\n        userInfo[_pool][msg.sender] = _user;\n\n        // Interactions\n        if (_pendingReward != 0) {\n            REWARD_TOKEN.safeTransfer(_to, _pendingReward);\n        }\n\n        emit Claimed(msg.sender, _pool, _pendingReward);\n    }\n\n    /// @notice Withdraw NFT token from pool and claim proceeds for transaction sender to `to`.\n    /// @param _pool address of the pool. See `NFTPoolInfo`.\n    /// @param _to Receiver of the LP tokens and syUSD rewards.\n    function withdrawAndClaim(address _pool, uint256 _tokenId, address _to) external {\n        require(tokenOwner[_pool][_tokenId] == msg.sender, \"NftStaking: not access to tokenId\");\n        NFTPoolInfo memory _poolInfo = updatePool(_pool);\n        UserInfo memory _user = userInfo[_pool][msg.sender];\n\n        uint256 _lockAmount = ISynthrNFT(_pool).lockAmount(_tokenId);\n\n        int256 accumulatedReward = _calAccRewardPerShare(_poolInfo.accRewardPerShare, _user.amount);\n        uint256 _pendingReward = uint256(accumulatedReward - (_user.rewardDebt));\n\n        // Effects\n        _user.rewardDebt = accumulatedReward - (_calAccRewardPerShare(_poolInfo.accRewardPerShare, _lockAmount));\n        _user.amount -= _lockAmount;\n        userInfo[_pool][msg.sender] = _user;\n\n        // Interactions\n        if (_pendingReward != 0) {\n            REWARD_TOKEN.safeTransfer(_to, _pendingReward);\n        }\n\n        ISynthrNFT(_pool).transferFrom(address(this), msg.sender, _tokenId);\n\n        delete tokenOwner[_pool][_tokenId];\n\n        emit WithdrawAndClaim(_pool, msg.sender, _pendingReward);\n    }\n\n    function _pendingRewardAmount(address _pool, address _user, uint256 _blockNumber)\n        internal\n        view\n        returns (uint256 _pending)\n    {\n        uint256 _lpSupply = totalLockAmount;\n        NFTPoolInfo memory _poolInfo = poolInfo[_pool];\n        UserInfo memory _userInfo = userInfo[_pool][_user];\n        uint256 _accRewardPerShare = _poolInfo.accRewardPerShare;\n        if (_blockNumber > _poolInfo.lastRewardBlock && _lpSupply != 0) {\n            uint256 _blocks = _blockNumber - (_poolInfo.lastRewardBlock);\n            uint256 _rewardAmount = (_blocks * _poolInfo.rewardPerBlock);\n            _accRewardPerShare += (_calAccPerShare(_rewardAmount, _lpSupply));\n        }\n        _pending = uint256(_calAccRewardPerShare(_accRewardPerShare, _userInfo.amount) - _userInfo.rewardDebt);\n    }\n\n    function _calAccPerShare(uint256 _rewardAmount, uint256 _lpSupply) internal pure returns (uint256) {\n        return (_rewardAmount * ACC_REWARD_PRECISION) / _lpSupply;\n    }\n\n    function _calAccRewardPerShare(uint256 _accRewardPerShare, uint256 _amount) internal pure returns (int256) {\n        return int256((_amount * _accRewardPerShare) / ACC_REWARD_PRECISION);\n    }\n}\n"
    },
    "contracts/VotingEscrow.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\nimport \"./interfaces/ISmartWalletChecker.sol\";\nimport \"./interfaces/IGaugeController.sol\";\n\ncontract VotingEscrow is AccessControl, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant DEPOSIT_FOR_TYPE = 0;\n    uint256 public constant CREATE_LOCK_TYPE = 1;\n    uint256 public constant INCREASE_LOCK_AMOUNT = 2;\n    uint256 public constant INCREASE_UNLOCK_TIME = 3;\n    uint256 public constant INCREASE_UNLOCK_TIME_AND_LOCK_AMOUNT = 4;\n\n    uint256 public constant WEEK = 7 * 86400; // all future times are rounded by week\n    uint256 public constant MAXTIME = 4 * 365 * 86400; // 4 years\n    uint256 public constant MULTIPLIER = 10 ** 18;\n\n    bytes32 public constant CONTROLLER_ROLE = keccak256(\"CONTROLLER_ROLE\");\n\n    struct Point {\n        int256 bias;\n        int256 slope;\n        uint256 timeStamp;\n        uint256 blockNumber;\n    }\n\n    struct LockedBalance {\n        int256 amount;\n        uint256 end;\n    }\n\n    string public name;\n    string public symbol;\n    string public version;\n\n    uint256 public decimals;\n    uint256 public supply;\n    uint256 public epoch;\n\n    address public futureSmartWalletChecker;\n    address public smartWalletChecker;\n\n    address public admin;\n    address public futureAdmin;\n\n    address public token;\n    address public controller;\n    address public gaugeController;\n\n    bool public transfersEnabled;\n\n    Point[100000000000000000000000000000] public pointHistory;\n\n    mapping(address => LockedBalance) public locked;\n    mapping(address => uint256) public createLockTs;\n    mapping(address => Point[1000000000]) public userPointHistory;\n    mapping(address => uint256) public userPointEpoch;\n    mapping(uint256 => uint256) public slopeChanges;\n\n    event OwnershipCommited(address admin);\n    event OwnershipApplied(address admin);\n    event WalletCommited(address newSmartWalletChecker);\n    event ControllerChanged(address indexed prevController, address indexed newController);\n    event Deposited(address indexed provider, uint256 value, uint256 indexed locktime, uint256 _type, uint256 ts);\n    event Withdrew(address indexed provider, uint256 value, uint256 timeStamp);\n    event Supply(uint256 prevSupply, uint256 supply);\n    event GaugeUpdated(address indexed newGauge);\n\n    constructor(\n        address _tokenAddr,\n        address _gaugeController,\n        string memory _name,\n        string memory _symbol,\n        string memory _version\n    ) {\n        admin = msg.sender;\n        token = _tokenAddr;\n        gaugeController = _gaugeController;\n        pointHistory[0].blockNumber = block.number;\n        pointHistory[0].timeStamp = block.timestamp;\n        controller = msg.sender;\n        transfersEnabled = true;\n\n        uint256 _decimals = ERC20(_tokenAddr).decimals();\n        require(_decimals <= 255);\n        decimals = _decimals;\n\n        name = _name;\n        symbol = _symbol;\n        version = _version;\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(CONTROLLER_ROLE, msg.sender);\n    }\n\n    function getLastUserSlope(address _user) external view returns (int256) {\n        uint256 uepoch = userPointEpoch[_user];\n        return userPointHistory[_user][uepoch].slope;\n    }\n\n    function userPointHistoryTs(address _user, uint256 _idx) external view returns (uint256) {\n        return userPointHistory[_user][_idx].timeStamp;\n    }\n\n    function lockedEnd(address _user) external view returns (uint256) {\n        return locked[_user].end;\n    }\n\n    function balanceOf(address _user, uint256 _t) external view returns (uint256) {\n        uint256 _epoch = userPointEpoch[_user];\n        if (_epoch == 0) {\n            return 0;\n        } else {\n            Point memory lastPoint = userPointHistory[_user][_epoch];\n            lastPoint.bias -= lastPoint.slope * int256(_t - lastPoint.timeStamp);\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n            return uint256(int256(lastPoint.bias));\n        }\n    }\n\n    function balanceOfAt(address _user, uint256 _block) external view returns (uint256) {\n        require(_block <= block.number, \"VotingEscrow: Wrong condition\");\n        uint256 _min;\n        uint256 _max = userPointEpoch[_user];\n        for (uint256 i; i < 128; ++i) {\n            if (_min >= _max) {\n                break;\n            }\n            uint256 _mid = (_min + _max + 1) / 2;\n            if (userPointHistory[_user][_mid].blockNumber <= _block) {\n                _min = _mid;\n            } else {\n                _max = _mid - 1;\n            }\n        }\n        Point memory upoint = userPointHistory[_user][_min];\n        uint256 maxEpoch = epoch;\n        uint256 _epoch = _findBlockEpoch(_block, maxEpoch);\n        Point memory point0 = pointHistory[_epoch];\n        uint256 blockDifference;\n        uint256 timeStampDiffrence;\n        if (_epoch < maxEpoch) {\n            Point memory point1 = pointHistory[_epoch + 1];\n            blockDifference = point1.blockNumber - point0.blockNumber;\n            timeStampDiffrence = point1.timeStamp - point0.timeStamp;\n        } else {\n            blockDifference = block.number - point0.blockNumber;\n            timeStampDiffrence = block.timestamp - point0.timeStamp;\n        }\n\n        uint256 blockTime = point0.timeStamp;\n        if (blockDifference != 0) {\n            blockTime += (timeStampDiffrence * (_block - point0.blockNumber)) / blockDifference;\n        }\n        upoint.bias -= upoint.slope * int128(int256(blockTime - upoint.timeStamp));\n        if (upoint.bias >= 0) {\n            return uint256(int256(upoint.bias));\n        } else {\n            return 0;\n        }\n    }\n\n    function totalSupply(uint256 _t) external view returns (uint256) {\n        uint256 _epoch = epoch;\n        Point memory lastPoint = pointHistory[_epoch];\n        return _supplyAt(lastPoint, _t);\n    }\n\n    function totalSupplyAt(uint256 _block) external view returns (uint256) {\n        require(_block <= block.number, \"VotingEscrow: Invalid Block Number\");\n        uint256 _epoch = epoch;\n        uint256 targetEpoch = _findBlockEpoch(_block, _epoch);\n        Point memory point = pointHistory[targetEpoch];\n        uint256 timeStampDiffrence;\n        if (targetEpoch < _epoch) {\n            Point memory pointNext = pointHistory[targetEpoch + 1];\n            if (point.blockNumber != pointNext.blockNumber) {\n                timeStampDiffrence = ((_block - point.blockNumber) * (pointNext.timeStamp - point.timeStamp))\n                    / (pointNext.blockNumber - point.blockNumber);\n            }\n        } else {\n            if (point.blockNumber != block.number) {\n                timeStampDiffrence = timeStampDiffrence = (\n                    (_block - point.blockNumber) * (block.timestamp - point.timeStamp)\n                ) / (block.number - point.blockNumber);\n            }\n        }\n        return _supplyAt(point, point.timeStamp + timeStampDiffrence);\n    }\n\n    function changeController(address _newController) external {\n        require(hasRole(CONTROLLER_ROLE, msg.sender), \"VotingEscrow: Invalid Caller\");\n        _revokeRole(CONTROLLER_ROLE, msg.sender);\n        _grantRole(CONTROLLER_ROLE, _newController);\n        controller = _newController;\n\n        emit ControllerChanged(msg.sender, _newController);\n    }\n\n    function setGaugeController(address _newController) external {\n        gaugeController = _newController;\n        emit GaugeUpdated(_newController);\n    }\n\n    function checkpoint() external {\n        _checkpoint(address(0), LockedBalance(0, 0), LockedBalance(0, 0));\n    }\n\n    function commitTransferOwnership(address _user) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"VotingEscrow: admin only\");\n        futureAdmin = _user;\n        emit OwnershipCommited(_user);\n    }\n\n    function applyTransferOwnership() external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"VotingEscrow: admin only\");\n        address _admin = futureAdmin;\n        require(_admin != address(0), \"VotingEscrow: Admin not set\");\n        admin = _admin;\n        emit OwnershipApplied(_admin);\n    }\n\n    function commitSmartWalletChecker(address _user) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"VotingEscrow: admin only\");\n        futureSmartWalletChecker = _user;\n        emit WalletCommited(_user);\n    }\n\n    function applySmartWalletChecker() external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"VotingEscrow: admin only\");\n        smartWalletChecker = futureSmartWalletChecker;\n        emit WalletCommited(futureSmartWalletChecker);\n    }\n\n    function depositFor(address _user, uint256 _value) external nonReentrant {\n        LockedBalance memory _locked = locked[_user];\n\n        require(_value > 0, \"VotingEscrow: Need non-zero value\");\n        require(_locked.amount > 0, \"VotingEscrow: No existing lock found\");\n        require(_locked.end > block.timestamp, \"VotingEscrow: Cannot add to an expired lock. Withdraw\");\n\n        _depositFor(_user, _value, 0, locked[_user], DEPOSIT_FOR_TYPE);\n    }\n\n    function createLock(uint256 _value, uint256 _unlockTime) external nonReentrant {\n        _assertNotContract(msg.sender);\n        uint256 unlockTime = (_unlockTime / WEEK) * WEEK;\n        LockedBalance storage _locked = locked[msg.sender];\n\n        require(_value > 0, \"VotingEscrow: need non-zero value\");\n        require(_locked.amount == 0, \"VotingEscrow: Withdraw old tokens first\");\n        require(unlockTime > block.timestamp, \"VotingEscrow: Can only lock until a time in the future\");\n        require(unlockTime <= MAXTIME + block.timestamp, \"VotingEscrow: Voting lock can be 4 years max\");\n        createLockTs[msg.sender] = block.timestamp;\n        _depositFor(msg.sender, _value, unlockTime, _locked, CREATE_LOCK_TYPE);\n    }\n\n    function increaseAmount(uint256 _value) external nonReentrant {\n        _assertNotContract(msg.sender);\n        LockedBalance storage _locked = locked[msg.sender];\n\n        require(_value > 0, \"VotingEscrow: need non-zero value\");\n        require(_locked.amount > 0, \"VotingEscrow: No existing lock found\");\n        require(_locked.end > block.timestamp, \"VotingEscrow: Cannot add to an expired lock. Withdraw\");\n\n        _depositFor(msg.sender, _value, 0, _locked, INCREASE_LOCK_AMOUNT);\n    }\n\n    function increaseAmountAndUnlockTime(uint256 _value, uint256 _unlockTime) external nonReentrant {\n        _assertNotContract(msg.sender);\n        LockedBalance storage _locked = locked[msg.sender];\n        uint256 unlockTime = (_unlockTime / WEEK) * WEEK;\n\n        require(_value > 0, \"VotingEscrow: need non-zero value\");\n        require(_locked.amount > 0, \"VotingEscrow: No existing lock found\");\n        require(_locked.end > block.timestamp, \"VotingEscrow: Cannot add to an expired lock. Withdraw\");\n        require(unlockTime > _locked.end, \"VotingEscrow: Can only increase lock duration\");\n        require(unlockTime <= block.timestamp + MAXTIME, \"VotingEscrow: Voting lock can be 4 years max\");\n\n        _depositFor(msg.sender, _value, unlockTime, _locked, INCREASE_UNLOCK_TIME_AND_LOCK_AMOUNT);\n    }\n\n    function withdraw() external nonReentrant {\n        LockedBalance storage _locked = locked[msg.sender];\n        require(block.timestamp >= _locked.end, \"VotingEscrow: The lock didn't expire\");\n        uint256 _value = uint256(int256(_locked.amount));\n        LockedBalance storage oldLocked = _locked;\n        _locked.end = 0;\n        _locked.amount = 0;\n        supply -= _value;\n\n        _checkpoint(msg.sender, oldLocked, _locked);\n        IERC20(token).safeTransfer(msg.sender, _value);\n        IGaugeController(gaugeController).updateReward(address(this), msg.sender, _value, false);\n        delete createLockTs[msg.sender];\n        emit Withdrew(msg.sender, _value, block.timestamp);\n        emit Supply(supply + _value, supply);\n    }\n\n    function increaseUnlockTime(uint256 _unlockTime) external nonReentrant {\n        _assertNotContract(msg.sender);\n        LockedBalance storage _locked = locked[msg.sender];\n        uint256 unlockTime = (_unlockTime / WEEK) * WEEK;\n        require(_locked.end > block.timestamp, \"VotingEscrow: Lock expired\");\n        require(_locked.amount > 0, \"VotingEscrow: Nothing is locked\");\n        require(unlockTime > _locked.end, \"VotingEscrow: Can only increase lock duration\");\n        require(unlockTime <= block.timestamp + MAXTIME, \"VotingEscrow: Voting lock can be 4 years max\");\n\n        _depositFor(msg.sender, 0, unlockTime, _locked, INCREASE_UNLOCK_TIME);\n    }\n\n    function _findBlockEpoch(uint256 _block, uint256 _maxEpoch) internal view returns (uint256) {\n        uint256 _min = 0;\n        uint256 _max = _maxEpoch;\n        for (uint256 i = 0; i < 128; i++) {\n            if (_min >= _max) {\n                break;\n            }\n            uint256 _mid = (_min + _max + 1) / 2;\n            if (pointHistory[_mid].blockNumber <= _block) {\n                _min = _mid;\n            } else {\n                _max = _mid - 1;\n            }\n        }\n        return _min;\n    }\n\n    function _supplyAt(Point memory _point, uint256 _time) internal view returns (uint256) {\n        Point memory lastPoint = _point;\n        uint256 timeInterval = (lastPoint.timeStamp / WEEK) * WEEK;\n        for (uint256 i; i < 255; ++i) {\n            timeInterval += WEEK;\n            int128 dSlope;\n            if (timeInterval > _time) {\n                timeInterval = _time;\n            } else {\n                dSlope = int128(int256(slopeChanges[timeInterval]));\n            }\n            lastPoint.bias -= lastPoint.slope * int256(timeInterval - lastPoint.timeStamp);\n            if (timeInterval == _time) {\n                break;\n            }\n            lastPoint.slope += dSlope;\n            lastPoint.timeStamp = timeInterval;\n        }\n        if (lastPoint.bias < 0) {\n            lastPoint.bias = 0;\n        }\n        return uint256(int256(lastPoint.bias));\n    }\n\n    function _assertNotContract(address _user) internal {\n        if (_user != tx.origin) {\n            address checker = smartWalletChecker;\n            if (checker != address(0)) {\n                if (ISmartWalletChecker(checker).check(_user)) {\n                    return;\n                }\n            }\n            revert(\"VotingEscrow: Smart contract depositors not allowed\");\n        }\n    }\n\n    function _checkpoint(address _user, LockedBalance memory _oldLocked, LockedBalance memory _newLocked) internal {\n        Point memory _uOld;\n        Point memory _uNew;\n        int256 _oldDslope = 0;\n        int256 _newDslope = 0;\n        uint256 _epoch = epoch;\n\n        if (_user != address(0)) {\n            // Calculate slopes and biases\n            // Kept at zero when they have to\n            if (_oldLocked.end > block.timestamp && _oldLocked.amount > 0) {\n                unchecked {\n                    _uOld.slope = _oldLocked.amount / int256(MAXTIME);\n                }\n                _uOld.bias = _uOld.slope * int256(_oldLocked.end - block.timestamp);\n            }\n            if (_newLocked.end > block.timestamp && _newLocked.amount > 0) {\n                unchecked {\n                    _uNew.slope = _newLocked.amount / int256(MAXTIME);\n                }\n                _uNew.bias = _uNew.slope * int256(_newLocked.end - block.timestamp);\n            }\n\n            // Read values of scheduled changes in the slope\n            // _oldLocked.end can be in the past and in the future\n            // _newLocked.end can ONLY by in the FUTURE unless everything expired than zeros\n            _oldDslope = int256(slopeChanges[_oldLocked.end]);\n            if (_newLocked.end != 0) {\n                if (_newLocked.end == _oldLocked.end) {\n                    _newDslope = _oldDslope;\n                } else {\n                    _newDslope = int256(slopeChanges[_newLocked.end]);\n                }\n            }\n        }\n        Point memory _lastPoint = Point({bias: 0, slope: 0, timeStamp: block.timestamp, blockNumber: block.number});\n        if (_epoch > 0) {\n            _lastPoint = pointHistory[_epoch];\n        }\n        uint256 _lastCheckpoint = _lastPoint.timeStamp;\n        // _initial_lastPoint is used for extrapolation to calculate block number\n        // (approximately, for *At methods) and save them\n        // as we cannot figure that out exactly from inside the contract\n        Point memory _initialLastPoint = _lastPoint;\n        uint256 _blockSlope = 0; // dblock/dt\n        if (block.timestamp > _lastPoint.timeStamp) {\n            _blockSlope =\n                (MULTIPLIER * (block.number - _lastPoint.blockNumber)) / (block.timestamp - _lastPoint.timeStamp);\n        }\n        // If last point is already recorded in this block, slope=0\n        // But that's ok b/c we know the block in such case\n\n        // Go over weeks to fill history and calculate what the current point is\n        uint256 _timeInterval;\n        unchecked {\n            _timeInterval = (_lastCheckpoint / WEEK) * WEEK;\n        }\n        for (uint256 i; i < 255;) {\n            // Hopefully it won't happen that this won't get used in 5 years!\n            // If it does, users will be able to withdraw but vote weight will be broken\n            _timeInterval += WEEK;\n            int256 d_slope = 0;\n            if (_timeInterval > block.timestamp) {\n                _timeInterval = block.timestamp;\n            } else {\n                d_slope = int256(slopeChanges[_timeInterval]);\n            }\n            _lastPoint.bias = _lastPoint.bias - _lastPoint.slope * int256(_timeInterval - _lastCheckpoint);\n            _lastPoint.slope += d_slope;\n            if (_lastPoint.bias < 0) {\n                // This can happen\n                _lastPoint.bias = 0;\n            }\n            if (_lastPoint.slope < 0) {\n                // This cannot happen - just in case\n                _lastPoint.slope = 0;\n            }\n            _lastCheckpoint = _timeInterval;\n            _lastPoint.timeStamp = _timeInterval;\n            _lastPoint.blockNumber = _initialLastPoint.blockNumber\n                + ((_blockSlope * (_timeInterval - _initialLastPoint.timeStamp)) / MULTIPLIER);\n            _epoch += 1;\n            if (_timeInterval == block.timestamp) {\n                _lastPoint.blockNumber = block.number;\n                break;\n            } else {\n                pointHistory[_epoch] = _lastPoint;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        epoch = _epoch;\n        // Now pointHistory is filled until t=now\n\n        if (_user != address(0)) {\n            // If last point was in this block, the slope change has been applied already\n            // But in such case we have 0 slope(s)\n            _lastPoint.slope += _uNew.slope - _uOld.slope;\n            _lastPoint.bias += _uNew.bias - _uOld.bias;\n            if (_lastPoint.slope < 0) {\n                _lastPoint.slope = 0;\n            }\n            if (_lastPoint.bias < 0) {\n                _lastPoint.bias = 0;\n            }\n        }\n        // Record the changed point into history\n        pointHistory[_epoch] = _lastPoint;\n\n        address _user2 = _user; //To avoid being \"Stack Too Deep\"\n\n        if (_user2 != address(0)) {\n            // Schedule the slope changes (slope is going down)\n            // We subtract new_user_slope from [_newLocked.end]\n            // and add old_user_slope to [_oldLocked.end]\n            if (_oldLocked.end > block.timestamp) {\n                // _oldDslope was <something> - _uOld.slope, so we cancel that\n                _oldDslope += _uOld.slope;\n                if (_newLocked.end == _oldLocked.end) {\n                    _oldDslope -= _uNew.slope; // It was a new deposit, not extension\n                }\n                slopeChanges[_oldLocked.end] = uint256(_oldDslope);\n            }\n            if (_newLocked.end > block.timestamp) {\n                if (_newLocked.end > _oldLocked.end) {\n                    _newDslope -= _uNew.slope; // old slope disappeared at this point\n                    slopeChanges[_newLocked.end] = uint256(_newDslope);\n                }\n                // else we recorded it already in _oldDslope\n            }\n\n            // Now handle user history\n            uint256 _user_epoch;\n            unchecked {\n                _user_epoch = userPointEpoch[_user2] + 1;\n            }\n\n            userPointEpoch[_user2] = _user_epoch;\n            _uNew.timeStamp = block.timestamp;\n            _uNew.blockNumber = block.number;\n            userPointHistory[_user2][_user_epoch] = _uNew;\n        }\n    }\n\n    function _depositFor(\n        address _user,\n        uint256 _value,\n        uint256 _unlockTime,\n        LockedBalance memory lockedBalance,\n        uint256 _type\n    ) internal {\n        LockedBalance memory _locked = lockedBalance;\n        uint256 supplyBefore = supply;\n        supply = supplyBefore + _value;\n        LockedBalance memory oldLocked = _locked;\n        _locked.amount += int128(uint128(_value));\n        if (_unlockTime != 0) {\n            _locked.end = _unlockTime;\n        }\n        locked[_user] = _locked;\n        _checkpoint(_user, oldLocked, _locked);\n        if (_value != 0) {\n            IERC20(token).safeTransferFrom(_user, address(this), _value);\n            IGaugeController(gaugeController).updateReward(address(this), _user, _value, true);\n        }\n        emit Deposited(_user, _value, _locked.end, _type, block.timestamp);\n        emit Supply(supplyBefore, supplyBefore + _value);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}